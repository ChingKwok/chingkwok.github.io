<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AbstractQueuedSynchronizer(AQS)原理笔记</title>
      <link href="/2022/07/02/%E4%BB%8EAbstractQueuedSynchronizer-AQS-%E7%9C%8BReentrantLock%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/02/%E4%BB%8EAbstractQueuedSynchronizer-AQS-%E7%9C%8BReentrantLock%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="队列同步器的作用">队列同步器的作用</h2><p>在多线程应用中，关键在于对<strong>状态依赖的管理</strong>以及对<strong>线程状态的管理</strong>。<br>因为资源不是无限的，如I/O资源、内存资源、CPU资源等，需要对线程进行控制，获取不到资源的线程需要进行阻塞或者挂起，这就引入了队列同步器中的一个关键属性：队列，获取不到资源的线程需要阻塞，然后在队列中等待唤醒。</p><h4 id="状态依赖管理">状态依赖管理</h4><p>对于加锁有前验的条件验证，也就是状态依赖。如：一个阻塞队列，put的时候队列不能为满，get的时候队列不能为空等。在一个线程安全类中，通常不止一个需要唤醒线程情况，如果使用Synchronized进行实现，就会产生不少问题，在下面会进行讲解。</p><h3 id="条件队列">条件队列</h3><p>如果我们能够将等待不同条件的线程分开进行管理，如一个阻塞队列，在get为空的时候阻塞，则需要被put的操作唤醒，而不是get操作，这时候就引入了<strong>条件队列</strong>这一概念了，条件队列可以使得一组线程组成一条或多条队列，对特定条件进行排队等待。</p><h4 id="条件谓语">条件谓语</h4><p>条件谓语就是线程能够继续执行的前验条件，一个条件队列可能会有一个或多个条件谓语，条件谓语成真时线程继续执行，否则等待谓语成真。一个条件队列就是一组线程等待一个条件谓语组成的，多个条件队列就组成了一个完整的同步工具类，如 <code>ReentrantLock</code></p><h3 id="线程唤醒时的意外情况">线程唤醒时的意外情况</h3><h4 id="过早唤醒">过早唤醒</h4><p>由于一个条件队列中可能会有多个条件谓语，在线程被唤醒时，可能并不意味着这个线程等待的条件谓语成真，所以需要在被唤醒之后再进行一次条件谓语的验证，不为真则继续等待。</p><h4 id="丢失信号">丢失信号</h4><p>线程A通知了一个条件队列，线程B随后在这个条件队列中等待，线程B错过了通知需要等待另一个通知才能醒来。在线程等待之前没有做条件谓语为真的校验就会导致丢失信号。</p><h2 id="AbstractQueuedSynchronizer的组成">AbstractQueuedSynchronizer的组成</h2><ul><li><p>资源状态 State<br>在独占锁的场景下, 可以理解为资源占有的标识位; 在共享锁的情况下, 可以作为资源数量理解.</p></li><li><p>双向等待队列（CLH队列）<br>CLH队列全称是(Craig, Landin, andHagersten) lock queue, 用来存储被阻塞的线程信息.</p></li></ul><h3 id="独占锁和共享锁">独占锁和共享锁</h3><ul><li><p>共享锁<br>可以有多个线程同时执行, 线程执行个数也会受到state限制, 如Semaphore,CountDownLatch等等</p></li><li><p>独占锁<br>当前只有一个线程能够运行, 如ReentrantLock;</p></li></ul><h3 id="公平锁和非公平锁">公平锁和非公平锁</h3><ul><li>公平锁<br>在请求资源时，如果无法获取，严格按照队列顺序，进入等待队列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非公平锁<br>每个线程不管是否有其他线程等待, 都会先通过CAS操作尝试抢占锁, 抢占失败再去CLH队列中等待锁资源释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock.java</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CAS操作">CAS操作</h3><p>AQS在获得资源状态state, 以及添加阻塞线程到CLH队尾时都是使用CAS操作解决线程间资源抢占问题的</p><ul><li>获取资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>添加线程到CLH队尾, Node中封装线程及锁独占或共享标识</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程阻塞及唤醒">线程阻塞及唤醒</h3><p>在AQS中, 当线程抢占资源失败时, 会调用unsafe.park()方法阻塞线程;</p><p>当其他线程释放资源时, 也会调用unsafe.unpark()唤醒线程;</p><h3 id="条件谓语-2">条件谓语</h3><p>AQS中将条件谓语封装成 <code>Condition</code> ，一个 <code>Condition</code> 会记录线程等待头节点和尾节点，实现在唤醒时对需要的阻塞线程进行唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractQueuedSynchronizer.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地事务实现笔记</title>
      <link href="/2022/06/05/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/05/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="本地事务高效实现">本地事务高效实现</h1><h2 id="事务需要处理以下情况">事务需要处理以下情况</h2><ol><li>未提交事务，写入后崩溃</li><li>已提交事务，写入后崩溃</li></ol><h2 id="事务实现方式">事务实现方式</h2><p><strong>提前写入技术（Write-Ahead Logging）</strong></p><p>写入raw data的时机：</p><ol><li>在写commit record之前就写raw data**（steal）**</li><li>在写commit record时**（force）**</li><li>在写commit record之后才写raw data。<strong>（no-force）</strong></li></ol><p><strong>recovery过程</strong></p><ol><li><p>前滚</p><p>出现已提交未入库的数据，在commit record之后未入库就出现崩溃，需要通过读取redo log中的checkpoint到commit recored之间的日志进行入库落盘。</p></li><li><p>后滚</p><p>出现未提交已落库的数据，在commit record之前因为steal写入了数据，需要根据undo log进行获取到最后一个commit record到checkpoint之间的日志进行回滚。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL底层：InnoDB记录结构笔记</title>
      <link href="/2022/05/29/MySQL%E5%BA%95%E5%B1%82%EF%BC%9AInnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/29/MySQL%E5%BA%95%E5%B1%82%EF%BC%9AInnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql底层——InnoDB记录结构">Mysql底层——InnoDB记录结构</h1><h3 id="页">页</h3><p>默认 <code>16K</code> 大小一页，每页至少两条记录</p><p>名词说明：</p><p><code>W</code> : 某个字符集中单字符的最大字节</p><p><code>M</code> : 某个数据类型能存储的最大字符</p><p><code>L</code> : 实际存储的字节数，最大等于 <code>W</code> * <code>M</code></p><h3 id="行格式">行格式</h3><p>四种行格式：Compact、Redundant、Dynamic（默认）、Compressed</p><h4 id="Dynamic：">Dynamic：</h4><p>与 <code>Compact</code> 的区别在于溢出页，会将溢出的字段整个放入 <code>溢出页</code> ，在 <code>记录的真实数据</code> 中只记录 <code>溢出页</code> 的地址</p><h4 id="Compact：">Compact：</h4><p>Compact行格式的结构：<br>- 变长字段长度列表<br>- Null值列表<br>- 记录头信息<br>- 记录的真实数据</p><p><strong>变长字段长度列表</strong></p><p>只存储非NULL值</p><p>使用1或2字节存储一个字段的长度</p><p>情况1：如果 <code>M</code> * <code>W</code> ≤ 255，使用1个字节标识实际占用字节数 <code>L</code></p><p>情况2：如果 <code>M</code> * <code>W</code> &gt; 255时，分两种情况</p><p>情况a：如果 <code>L</code> ≤127,则用1个字节标识实际占用的字节数</p><p>情况b：如果 <code>L</code> ≥ 127,则用2个字节标识实际占用的字节数</p><p><strong>NULL值列表</strong></p><p>每列使用1bit空间，按照列的顺序从低位到高位进行存放，1为NULL，0为不为NULL</p><p>最小单位为字节，不够则在高位补零</p><p><strong>记录头信息</strong></p><p>固定用 <code>5</code> 字节组成，用于记录记录是否被删除、B+树每层非叶子节点的最小记录信息等</p><p><strong>记录真实的数据</strong></p><p>除了定义的列外，还有隐藏的列：</p><p><code>DB_ROW_ID</code> ：行ID（非必须）</p><p><code>DB_TRX_ID</code> ：事务ID</p><p><code>DB_ROLL_PTR</code> ：回滚指针</p><p>其中 <code>DB_ROW_ID</code> 不是必须的，生成的规则：如果表没有主键，则使用一个 <code>Unique</code> 字段作为主键，如果没有这个字段，则会添加 <code>DB_ROW_ID</code> 列作为主键。</p><h4 id="其中比较特殊的类型">其中比较特殊的类型</h4><p><strong>NULL类型</strong></p><p>被NULL值列表存储，这里无需重复存储了</p><p><strong>CHAR(M)类型</strong></p><p>对于不可变长的字符集来说声明多少就占用多少实际空间</p><p>对于可变长的字符集，比如utf8mb3，长度就会加 <code>可变长字段长度列表</code> 中，一个字符1-3字节，CHAR类型至少占用 <code>M</code> 个字节，不够再申请新的记录空间</p><p><strong>行溢出数据</strong></p><p>Innodb数据库单页默认为 <code>16K</code> 大小，如果单页装不下一个记录，则会将溢出的数据放入 <code>溢出页</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收器G1对比CMS笔记</title>
      <link href="/2022/05/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8G1%E5%AF%B9%E6%AF%94CMS%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8G1%E5%AF%B9%E6%AF%94CMS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM垃圾回收器G1和CMS">JVM垃圾回收器G1和CMS</h1><p>因为在学习JVM的垃圾回收器的过程中，发现CMS这个垃圾回收器在JDK版本中几乎没有出场，取而代之的是类似于CMS的G1收集器，这篇笔记记录下这两者的异同，以及CMS退居幕后的原因。</p><h2 id="CMS收集器">CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><p>CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记这两个步骤仍然需要Stop-the-world。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</p><h3 id="优缺点">优缺点</h3><p>优点：并发收集、低停顿。</p><p>缺点：</p><ul><li>CMS收集器对CPU资源非常敏感。</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage）。</li><li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li></ul><h3 id="浮动垃圾是什么？">浮动垃圾是什么？</h3><p>CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 <strong>重新标记</strong> 的作用只是修改<strong>之前</strong>并发标记所获得的不可达对象，这部分对象就是浮动垃圾。</p><h2 id="G1收集器">G1收集器</h2><p>G1重新定义了堆空间，<strong>打破了原有的分代模型</strong>，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p><h3 id="回收流程">回收流程</h3><ul><li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，优先收集回收价值大的Region，这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul><h2 id="CMS对比G1">CMS对比G1</h2><h3 id="清除算法">清除算法</h3><p>与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p><h3 id="三色标记法">三色标记法</h3><p>CMS在三色标记法的实现中使用了增量更新</p><p>G1则使用了原始快照</p><h3 id="内存区域划分">内存区域划分</h3><p>CMS基于原来的年代分代模型</p><p>G1使用了新的基于Region模型，分为老年代Region、新生代Region、Humongous Region</p><h3 id="跨代引用记录">跨代引用记录</h3><p>因为G1引入了Region模型，所以在跨代引用中G1需要记录每个Region中的每个区域的跨代引用情况，对比CMS需要更大的内存空间进行存放记忆集，导致内存占用比较大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构源码学习笔记</title>
      <link href="/2022/05/01/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/01/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="【2022-5-28】Redis源码">【2022.5.28】Redis源码</h1><h2 id="字符串源码">字符串源码</h2><p>字符串由两个部分组成，一个是redis对象通用结构体 <code>RedisObject</code> ，一个是字符串特有的 <code>SDS(Simple Dynamic String)</code> 简单动态字符串结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisObject 16Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span>&#123;</span></span><br><span class="line">int4 type; <span class="comment">//对象类型，如字符串 4bits</span></span><br><span class="line">int4 encoding;  <span class="comment">//编码类型  4bits</span></span><br><span class="line">int24 lru;   <span class="comment">//LRU信息，用于淘汰key 24bits</span></span><br><span class="line">int32 refcount;   <span class="comment">//引用计数器 4Bytes</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;    <span class="comment">//指向实际存储位置的指针，也就是指向SDS的指针 根据系统位数不同64位系统是 8Bytes</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SDS &gt;=3Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt;&#123;</span></span><br><span class="line">T capacity;  <span class="comment">//分配的数组的长度，content的长度</span></span><br><span class="line">T len;  <span class="comment">//实际存储的字符串的长度</span></span><br><span class="line"><span class="keyword">byte</span> flags;  <span class="comment">//标志位</span></span><br><span class="line"><span class="keyword">byte</span>[] contents; <span class="comment">//内容数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的编码分为两种： <code>embstr</code> 和 <code>raw</code></p><p>embstr</p><p>使用 <code>malloc</code> 方法申请空间， <code>jemalloc</code> 分配空间大小是2/4/8/16/32/64字节，因为embstr最小需要19Bytes，所以给 <code>embstr</code> 最小分配32字节空间，稍微长一些就是64字节空间，Redis的逻辑是当embstr空间大于64字节时，转为 <code>raw</code> 存储</p><p>因为字符串为了便于使用 <code>glibc</code> 函数处理，以及便于调试打印输出，所以在实际存储中，会在字符串数组末尾加入 <code>NULL</code> 字符，占用1Byte</p><p>embstr编码下，字符串的最大字符数是：64-19-1=44Bytes</p><p>raw</p><p>与embstr不同，embstr是调用一次malloc函数申请空间，raw是调用两次malloc函数，申请两块不连续的空间，使用 <code>RedisObject</code> 中的 <code>*ptr</code> 指针进行指向SDS，在字符串大于44Bytes时会使用raw格式存储</p><h3 id="扩容策略">扩容策略</h3><p>当字符串小于1MB时，扩容contents数组时加倍扩容，而大于1MB时，每次扩容多分配1MB空间</p><h2 id="字典结构">字典结构</h2><p>字典结构应用到的地方由很多，比如redis作为远程字典服务器本身就是一个由key和value大字典，而在zset集合中score和value值也是一个字典，以及key的过期时间存储也是由字典实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//redisDB </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisDb</span>&#123;</span></span><br><span class="line">dict* dict;  <span class="comment">//所有的key key-&gt;value</span></span><br><span class="line">dict* expires; <span class="comment">//所有的key的过期时间  key-&gt;long(timestamp)</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zset</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">dict *dict;  <span class="comment">//所有value value-&gt;score</span></span><br><span class="line">zskiplist *zsl;  <span class="comment">//跳表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典结构中主要是有两个hashtable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">dictht ht[<span class="number">2</span>];  <span class="comment">//两个hashtable，用于在扩容时作为渐进式搬运的临时ht</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dictht</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">dictEntry** table;   <span class="comment">//指向数组的指针</span></span><br><span class="line"><span class="keyword">long</span> <span class="built_in">size</span>;  <span class="comment">//第一维数组的长度</span></span><br><span class="line">  <span class="keyword">long</span> used;  <span class="comment">//hash表中的元素个数</span></span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dictEntry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>* key;</span><br><span class="line"><span class="keyword">void</span>* val;</span><br><span class="line">dictEntry* next;  <span class="comment">//指向下一个entry的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash中的关键逻辑</p><ul><li>渐进式rehash：因为rehash是一个 <code>O(n)</code> 时间复杂度的操作，redis在rehash中维护两个hashtable，一个旧一个新，新增的entry会新增到新hash中，并且旧hash会逐渐在hset、hdel逻辑中主动搬运，如果没有这些操作，也会在定时任务中进行搬运。</li><li>hash函数会保证尽可能的使得元素在hashtable中均匀分布，但是如果有针对性的hash攻击，也会使得查找退化到O(n)</li><li>扩容逻辑：hash元素总数等于数组长度时开始扩容，尽量保证查找效率为 <code>O(1)</code> ，扩容为原数组大小的两倍，但如果在 <code>bgsave</code> 过程中，则会推延扩容直到元素总数达到数组长度的5倍，就会触发强制扩容</li><li>缩容逻辑：hash元素总数小于数组长度的10%时，触发缩容，缩容不会考虑 <code>bgsave</code></li></ul><h2 id="压缩列表（ziplist）">压缩列表（ziplist）</h2><p>有序集合 <code>zset</code> 在元素较少 <code>（&lt;128）&amp;（len&lt;64）</code> 时，会使用 <code>ziplist</code> ，这个数据结构没有空隙，所有元素都是紧挨着存放。</p><p>查找时间复杂度： <code>O(n)</code></p><p>插入时间复杂度： <code>O(n)</code></p><p>压缩链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span> &#123;</span></span><br><span class="line">int32 zlbytes; <span class="comment">//整个列表占用的字节数</span></span><br><span class="line">int32 zltail_offset;  <span class="comment">//最后一个元素距离压缩列表起始位置的偏移量，用于定位最后一个节点</span></span><br><span class="line">int16 zllength;  <span class="comment">//元素个数</span></span><br><span class="line">  T[] entries; <span class="comment">//元素内容数组</span></span><br><span class="line">  int8 zlend;  <span class="comment">//标记压缩列表的结束，魔法值，为0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>&lt;var&gt; prevlen;  <span class="comment">//前一个entry的字节长度</span></span><br><span class="line">  <span class="keyword">int</span>&lt;var&gt; encoding;  <span class="comment">//元素类型编码</span></span><br><span class="line">  optional <span class="keyword">byte</span>[] content; <span class="comment">//元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ziplist关键逻辑：</p><ul><li>级联更新：元素结构体中的prevlen是会根据前一个元素的改变实时更新的，会触发级联更新</li><li>元素结构体中的prevlen在字符串小于 <code>254</code> 时，使用一个字节，超出则使用5个字节</li><li>encoding设计十分复杂，可以表示数据类型、数据长度，甚至可以直接存储极小的整数（0-12）</li><li>新增元素时需要重新分配内存</li></ul><h2 id="intset小整数集合">intset小整数集合</h2><p>在 <code>set</code> 集合元素都是整数且元素较少 <code>&lt;512</code> 时，会使用 <code>intset</code> 进行存储， <code>intset</code> 支持16、32、64位整数，结构为紧凑型数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&lt;T&gt; &#123;</span></span><br><span class="line">int32 encoding; <span class="comment">//决定整数是多少位的，16/32/64</span></span><br><span class="line">  int32 length;  <span class="comment">//元素个数</span></span><br><span class="line">  <span class="keyword">int</span>&lt;T&gt; contents; <span class="comment">//整数数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速列表">快速列表</h2><p>快速列表结合了 <code>ziplist</code> 和 <code>linkedlist</code> ，在元素少时，只使用 <code>ziplist</code> ，元素较多时，把 <code>ziplist</code> 使用 <code>双向循环指针</code> 链接起来，成为一个由 <code>ziplist</code> 作为元素的 <code>linkedlist</code> 。</p><p>关键逻辑：</p><ul><li>ziplist节点本身也是可以压缩的，使用的是 <code>LZF算法</code> 压缩，可以选择压缩深度，所谓的压缩深度就是从首尾算起多少个元素可以不压缩，深度为0就是不压缩，深度大于0时越大压缩的ziplist越少。</li><li>一个ziplist存储有空间限制，可以通过 <code>list-max-ziplist-size</code> 设定，默认为8KB</li></ul><h2 id="跳跃列表">跳跃列表</h2><p>数据结构 <code>zset</code> 是复合结构，其中的结构包含了一个 <code>hash字典</code> 和 一个 <code>skiplist跳跃列表</code> ，其中 <code>skiplist</code> 是比较复杂的。</p><img src="/.io//05/01/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img1.png" class title="img1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zslnode 跳表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zslnode</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> value;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line">  zslnode*[] forwards; <span class="comment">//多层链接指针</span></span><br><span class="line">zslnode* backward; <span class="comment">//回溯指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zsl 跳表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zsl</span> &#123;</span></span><br><span class="line">zslnode* header; <span class="comment">//跳跃列表表头指针(kv head)</span></span><br><span class="line"><span class="keyword">int</span> maxLevel;  <span class="comment">//跳表最高层</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="built_in">string</span>, zslnode*&gt; ht; <span class="comment">//hash结构键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机层数">随机层数</h3><p>对于每一个新插入的元素，会调用一个随机算法来计算他最高处于哪个层，理论上每升一层的概率是50%，但是redis为了限制层高，把这个概率设置为了25%，也就是实际上redis中的跳表比理论的更矮。</p><h3 id="插入过程">插入过程</h3><ol><li>首先找到搜索路径</li><li>创建新节点，随机获取当前节点的层高</li><li>把节点的指针指向到对应的前后节点</li></ol><h3 id="更新过程">更新过程</h3><ol><li>找到对应的节点，如果需要更新，就删除</li><li>插入新节点</li></ol><h3 id="删除过程">删除过程</h3><ol><li>获取节点</li><li>删除节点</li></ol><h3 id="元素排名">元素排名</h3><p><code>rank</code> 是通过存储在 forward指针中的span（跨度）属性计算的，具体是在获取节点时，获取到搜索路径，将搜索路径中的span相加，就获得了排名了</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis IO线程模型</title>
      <link href="/2022/04/22/Redis-IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/04/22/Redis-IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程IO模型">线程IO模型</h3><p>阻塞型IO</p><p>在调用socket的读写方法时候，在阻塞的情况下，开始写入/读取后，除非结束不然会阻塞线程。</p><p>非阻塞型IO</p><p>非阻塞IO就是能读多少就读多少，能写多少就写多少，能读多少取决于内核为套接字分配的 <code>读缓冲区</code> 的字节数，能写多少取决于内核为套接字分配的 <code>写缓冲区</code> 的空闲空间字节数。读写完成后，直接返回，线程可以做其他事情，等待下一次读写。</p><p>事件轮询（多路复用）</p><p>在处理完其他逻辑后，需要重新读写时，调用多路复用API，如 <code>select(read_fds, write_fds, timeout)</code> ，因为select在一定数量描述符时会有严重的性能问题，现在一般使用 <code>epoll(linux)</code> 和 <code>kqueue(FreeBSD/Macosx)</code> ，传入读写描述符，返回读写事件，再通过读写事件进行读写， <code>timeout</code> 参数是用来避免等待事件轮询停顿过长事件，等待超过 <code>timeout</code> 事件就会中断获取事件直接返回。</p><h3 id="redis-reactor-I-O模型">redis reactor I/O模型</h3><ol><li>socket通信：连接redis服务器，服务器创建一个socket进行通信，产生AE_READABLE事件，并将AE_READABLE与连接应答处理器绑定，通过IO多路复用程序进入队列</li><li>文件事件处理器读取队列读取到AE_READABLE事件之后派发给连接应答处理器，连接答应处理器创建一个新的socket 01与这个客户端进行通信，然后将AE_READABLE事件和命令请求处理器绑定</li><li>客户端发送请求到服务器，服务器socket 01监听到请求，并发送AE_READABLE事件到IO多路复用程序，将请求加入队列</li><li>文件事件处理器读取队列读取到AE_READABLE事件之后，派发给命令请求处理器</li><li>命令请求处理器读取socket 01中的请求，处理请求，准备好给客户端的响应数据之后，将AE_WRITABLE事件绑定到命令回复处理器。当客户端准备好读取响应数据时，就会在socket产生一个AE_WRITABLE事件，事件进入队列中，文件事件分派器读取到后，分派给命令回复处理器，命令回复处理器将准备好的响应数据写入socket，让客户端来读取。</li><li>命令回复处理器写完之后，就会删除这个socket的AE_WRITABLE事件和命令回复处理器的关联关系。</li></ol><img src="/.io//04/22/Redis-IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/img1.png" class title="img1">]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis序列化协议RESP笔记</title>
      <link href="/2022/04/10/Redis%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AERESP%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/10/Redis%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AERESP%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="RESP（Redis-Serialization-Protocal）Redis序列化协议">RESP（Redis Serialization Protocal）Redis序列化协议</h3><p>Redis在客户端与服务端的通信中，使用的是 <code>RESP</code> 协议，这个协议虽然对消息体体积没有进行优化，但是容易解析，解析性能很好</p><p><code>RESP</code> 把消息分为5种最小单元类型，单元结束时加上 <code>\r\n</code></p><ol><li><code>+</code>  ：单行字符串</li><li><code>$</code> ：多行字符串</li><li><code>:</code> ：整数</li><li><code>-</code> ：错误信息</li><li><code>*</code> ：数组，可以嵌套其他类型单元</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池源码实现笔记</title>
      <link href="/2022/03/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池">线程池</h1><p><strong>Executor框架</strong></p><p>基于Executor框架，通过消费者-生产者模式，把任务的提交和执行分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Execute框架中，线程不是执行主要的抽象，任务才是。</p><p><strong>执行策略</strong></p><ul><li>在什么线程中执行任务</li><li>任务按照什么顺序执行（FIFO、LIFO、优先级）</li><li>有多少个任务能够并发执行</li><li>在队列中有多少个任务在等待执行</li><li>系统过载需要拒绝任务时，应该选哪个任务，并如何通知应用程序有任务被拒绝</li><li>执行任务之前之后，应该做哪些动作</li></ul><p><strong>ExecutorService</strong></p><p><code>ExecutorService</code> 拓展了 <code>Executor</code> ，拓展出了生命周期，用于管理处理器的生命周期，有：运行、关闭、已终止三个状态</p><p><strong>Timer和ScheduledThreadPoolExecutor区别</strong></p><ul><li><p>Timer</p><p>基于绝对时间调度机制</p><p>单线程执行，如果执行时间超过周期，则会漏执行</p><p>执行线程抛出未检查错误时不会恢复</p></li><li><p>ScheduledThreadPoolExecutor</p><p>基于相对时间调度机制</p><p>基于线程池执行</p></li></ul><p><strong>线程饥饿死锁</strong></p><p>在线程池中，执行中线程等待工作队列线程而导致死锁</p><p><strong>线程池构造参数</strong></p><ul><li><p>int corePoolSize</p><p>基本大小，决定了线程池在空闲的时候会留存多少闲置线程</p></li><li><p>int maximumPoolSize</p><p>最大大小，决定线程池同时活动线程数量的上限</p></li><li><p>long keepAliveTime</p><p>闲置线程存活时间</p></li><li><p>TimeUnit unit</p><p>时间单位</p></li><li><p>BlockingQueue workQueue</p></li><li><p>ThreadFactory threadFactory</p></li><li><p>RejectExecutionHandler handler</p><p>饱和策略：</p><ol><li>中止</li><li>调用者运行</li><li>抛弃最旧任务</li></ol></li></ul><p><strong>扩展ThreadPoolExecutor</strong></p><p>可以对线程池进行拓展，改写 <code>beforeExecute</code> 、 <code>afterExecute</code> 、 <code>terminated</code> ，实现对线程池的日志、监控、计时等功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的显式锁</title>
      <link href="/2022/03/02/Java%E4%B8%AD%E7%9A%84%E6%98%BE%E5%BC%8F%E9%94%81/"/>
      <url>/2022/03/02/Java%E4%B8%AD%E7%9A%84%E6%98%BE%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="Lock">Lock</h3><p>Lock接口的实现必须提供和内置锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证和性能上可以不同。</p><h3 id="ReentrantLock">ReentrantLock</h3><p><code>ReentrantLock</code> 实现了与 <code>synchronized</code> 相同的可重入锁实现，并且在 <code>java1.6</code> 之后性能相差无几。对比 <code>synchronized</code> ，<code>ReentrantLock</code> 实现了可定时、可轮询、可中断的获取锁操作。</p><p>注意点：使用 <code>ReentrantLock</code> 必须使用 <code>try-finally</code> 在finally代码块中释放锁。</p><h3 id="公平锁-非公平锁">公平锁&amp;非公平锁</h3><p>公平锁保证了后请求锁的线程，会在之前请求锁的线程之后获取到锁，但是这会极大降低性能，因为线程的挂起和恢复需要的cpu周期很长。</p><p>非公平锁提供了 <code>插队</code> 的功能，在线程A释放锁，线程B恢复线程的时间中，线程C可以 <code>插队</code> 获取到锁、使用、释放锁，线程B获取到锁的时机没有变化或者略微推延，这样就提高了吞吐量。</p><h3 id="读-写锁">读-写锁</h3><p>可选项：</p><ul><li>释放优先：在释放读锁或者写锁时，如果在等待的线程有等待读锁也有等待写锁的，优先给读锁还是写锁。</li><li>读线程插队：在读锁被获取后，并且有线程在等待写锁，新的线程过来获取读锁能否立刻获取读锁，或者是等待写锁获取后再获取读锁，这里可能会引发饥饿问题。</li><li>重入性：读锁和写锁是否可重入</li><li>降级：获取写锁之后能否在不释放锁的情况下降级成读锁。</li><li>升级：获取读锁之后能否在不释放锁的情况下升级成写锁。大部分读写锁实现中不会支持升级，因为如果两个读锁持有的线程同时申请写锁，就会造成死锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU淘汰算法简单实现</title>
      <link href="/2022/02/10/%E7%BC%93%E5%AD%98%E4%B8%89%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/10/%E7%BC%93%E5%AD%98%E4%B8%89%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="LRU（least-recently-used）">LRU（least recently used）</h3><p>LRU算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><h4 id="具体过程">具体过程</h4><ol><li>新数据插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><img src="/.io//02/10/%E7%BC%93%E5%AD%98%E4%B8%89%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B0/img1.png" class title="img1"><h4 id="数据结构">数据结构</h4><ul><li>HashMap：快速搜索的基础</li><li>双向链表：LRU顺序的基础</li></ul><h4 id="简单实现">简单实现</h4><p>根据定义手敲了一个，可能不太优雅，但是能用哈哈哈，仅供学习~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLRU</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Node&lt;T&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleLRU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleLRU</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        String key;</span><br><span class="line">        T value;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line">        Node&lt;T&gt; pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(String key, T value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != head &amp;&amp; node != tail) &#123;</span><br><span class="line">            <span class="comment">//中间节点处理</span></span><br><span class="line">            Node&lt;T&gt; p = node.pre;</span><br><span class="line">            Node&lt;T&gt; q = node.next;</span><br><span class="line">            p.next = q;</span><br><span class="line">            q.pre = p;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">            <span class="comment">//尾节点处理</span></span><br><span class="line">            tail = node.pre;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> || key.trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; oldNode;</span><br><span class="line">        <span class="comment">//已有对应key，只更新value</span></span><br><span class="line">        <span class="keyword">if</span> ((oldNode = map.get(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldNode.value = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class="line">            <span class="comment">//超出队列大小，先删除再新增</span></span><br><span class="line">            Node&lt;T&gt; delNode = tail;</span><br><span class="line">            String delKey = delNode.key;</span><br><span class="line">            map.remove(delKey);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (capacity == <span class="number">1</span>) &#123;</span><br><span class="line">                tail = newNode;</span><br><span class="line">                head = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//队列还有余量直接追加到map和队列中</span></span><br><span class="line">                Node&lt;T&gt; preNode = tail.pre;</span><br><span class="line">                preNode.next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = newNode;</span><br><span class="line">                tail = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = newNode;</span><br><span class="line">                newNode.pre = tail;</span><br><span class="line">                tail = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的性能和可伸缩性优化笔记</title>
      <link href="/2022/01/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是可伸缩性？">什么是可伸缩性？</h2><p>当硬件性能提升，如cpu提升、内存提升、IO性能提升时，应用程序的处理能力是否会跟随硬件有相应的增加。</p><h3 id="如何对可伸缩性进行优化的基准">如何对可伸缩性进行优化的基准</h3><p>开发中需要针对具体需求进行定制，如何以以测试为基准进行优化。</p><h3 id="多线程的可伸缩性的限制">多线程的可伸缩性的限制</h3><p>在所有的并发程度中都会有一部分的串行化的任务，如I/O阻塞、对阻塞队列进行读取和写入等</p><h3 id="JVM对锁的优化">JVM对锁的优化</h3><ul><li>锁消除，基于逃逸分析可以把没有逃逸出栈的对象中的锁消除。</li><li>锁粗化，将相邻的相同的锁的代码块进行合并。</li></ul><h3 id="线程引入的开销">线程引入的开销</h3><ol><li><p>上下文切换</p><p>5k-10k个时钟周期，大约几微秒</p></li><li><p>内存同步</p><p>内存栅栏刷新缓存，使得缓存无效的同时也禁止了大部分的指令重排序。</p><p>共享内存总线的带宽是有限的，过多的同步会导致总线上的线程陷入瓶颈</p></li></ol><h3 id="线程阻塞的方式">线程阻塞的方式</h3><p>JVM在处理线程阻塞时，有两种阻塞策略：自旋、挂起，一般采用挂起，因为通常来说被阻塞的线程不会在短时间内获取到资源。阻塞会导致两次上下文切换和系统操作和缓存操作。</p><h2 id="优化可伸缩性">优化可伸缩性</h2><h3 id="减少锁竞争">减少锁竞争</h3><p>关键：锁的请求频率、每次持有锁的时间</p><ul><li>缩小锁的范围</li><li>减小锁的粒度<ul><li>锁分解</li><li>锁分段</li></ul></li><li>热点域缓存</li><li>替代独占锁<ul><li>读写锁 <code>ReadWriteLock</code></li><li>原子变量：乐观锁 <code>CAS</code></li></ul></li></ul><h3 id="监测CPU利用率">监测CPU利用率</h3><p>命令： top</p><p>cpu负载不高的原因：</p><ul><li>负载不充分，应用程序压力不大</li><li>IO密集</li><li>外部限制，如远程调用、Web服务调用</li><li>锁竞争</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP和BASE理论笔记</title>
      <link href="/2021/10/03/CAP%E5%92%8CBASE%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/03/CAP%E5%92%8CBASE%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="CAP">CAP</h3><ul><li>C：Consistency，强一致性，在分布式系统中的所有数据备份，在同一时刻是否同样的值。</li><li>A：Available，可用性，在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li><li>P：Partition，分区容忍性，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>CAP理论是理想状态下的，不考虑网络时延，不考虑节点中间状态，所以实践中不可能完全满足AP或CP，一般会偏向某个实现</p><h3 id="BASE">BASE</h3><ul><li>BA：Base Available，基本可用性</li><li>S：Soft State，软状态即中间状态</li><li>E：Eventual Consistent，最终一致性</li></ul><p>对比CAP理论，BASE基于工程实现，考虑了客观存在的时延、网络分区问题，因为基于分布式，所以P是必备的，所以不需要特地说明，而是加入了S状态，即不同节点间数据完成同步前的状态，然后实现E，最终一致性</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程活跃性问题笔记</title>
      <link href="/2021/09/30/%E7%BA%BF%E7%A8%8B%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/30/%E7%BA%BF%E7%A8%8B%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线程在相互等待</p><h2 id="死锁">死锁</h2><ul><li>获取锁顺序导致死锁</li></ul><p>可以通过 <code>System.identityHashCode()</code> 方法获取锁对象的hash，然后通过hash值进行判断，保证每次获取锁的顺序都是一致的，避免因获取锁顺序导致死锁</p><ul><li>开放调用</li></ul><p>在获取了锁的方法中调用一个需要获取另一个锁的方法，可能会导致死锁，可以通过降低锁的粒度，使得方法调用同步代码块不包含需要获取锁的方法调用。保证开放调用。</p><ul><li>定时锁</li></ul><p>获取锁时设置超时时间，避免无限期等待下去</p><h2 id="饥饿">饥饿</h2><p>线程无法访问需要的资源导致无法执行，叫做饥饿，如等待cpu周期、等待其他锁释放。</p><h2 id="活锁">活锁</h2><p>线程陷入活锁时不会阻塞线程，但是会一直重试，循环执行相同的操作，例如消息队列消费者处理时出错回滚，并把消息重新发送回队列中，导致活锁，这样的消息也叫 <code>毒药消息(Poison Message)</code></p><p>在重试机制中引入随机性可以避免活锁</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis过期策略和淘汰机制笔记</title>
      <link href="/2021/09/20/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/20/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis如何过期删除过期key-value？">Redis如何过期删除过期key-value？</h3><p>惰性删除+定时删除</p><ul><li>惰性删除：只在查询一个过期的key时执行删除操作</li><li>定时删除：每隔一段时间（默认是100ms）随机抽取一些设置了过期时间的key，检查是否过期。</li></ul><h3 id="Redis如何在内存即将满的时候做淘汰数据？">Redis如何在内存即将满的时候做淘汰数据？</h3><ol><li>noeviction：内存不足时拒绝写操作</li><li>allkeys-lru：当内存不足时，在键空间中，移除最新最少使用的key</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key</li><li>volatile-lru：当内存不足时，在<strong>设置了过期时间的</strong>键空间中，移除最新最少使用的key</li><li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的</strong>键空间中，随机移除某个key</li><li>volatile-ttl：当内存不足时，在<strong>设置了过期时间的</strong>键空间中，优先移除更早过期的数据</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis并发竞争问题</title>
      <link href="/2021/09/14/Redis%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/14/Redis%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Redis并发竞争？">什么是Redis并发竞争？</h3><p>在一个服务集群同时对redis的某个key进行更新、删除时，可能会出现竞争，导致旧数据覆盖新数据存入Redis缓存中</p><h3 id="怎么解决">怎么解决</h3><ul><li>在写少读多的情况下：通过分布式锁，确保同一时间只有一个服务实例在操作redis的某个数据，并且通过时间戳判断数据新旧，旧数据不能覆盖新数据</li><li>在写多读多的情况下：可以通过Redis的Lua脚本实现原子操作快速根据时间戳更新或者丢弃，但是会降低Redis的吞吐量，需要进行权衡是否还需要缓存</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存击穿问题笔记</title>
      <link href="/2021/09/04/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/04/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是缓存击穿？">什么是缓存击穿？</h3><p>热点数据过期后的短时间内，大量请求访问，在查询DB写入缓存的过程中，大量DB请求涌入，导致DB慢查询或者崩溃。</p><h3 id="如何解决？">如何解决？</h3><ul><li>分布式互斥锁，通过分布式锁对查询进行线程数限制，并设置超时时间，超时报错。</li><li>手动过期：通过key-value格式存储数据，value为过期时间，某个线程读取到数据过期后，通过异步线程进行缓存的重新构建，避免击穿</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存穿透问题笔记</title>
      <link href="/2021/08/26/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/26/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是缓存穿透？">什么是缓存穿透？</h3><p>非正常用户大量请求缓存中不存在的数据，导致业务逻辑去数据库查找，导致数据库崩溃。</p><h3 id="缓存穿透解决方法">缓存穿透解决方法</h3><ol><li>基于数据规则进行判断非法请求。</li><li>每次在数据库查询不到就写一个空值到缓存中</li><li>布隆过滤器</li></ol><h3 id="布隆过滤器如何更新？">布隆过滤器如何更新？</h3><ol><li>尽量避免物理删除，做逻辑删除</li><li>开发定时任务，每隔几个小时，自动创建一个新的布隆过滤器数组，替换老的</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存雪崩问题笔记</title>
      <link href="/2021/08/10/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/10/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是缓存雪崩？">什么是缓存雪崩？</h3><p>系统在高负载的情况下，缓存实例发生大面积宕机，导致大量请求无法通过缓存返回，直接请求数据库，导致数据库崩溃。</p><h3 id="缓存雪崩的解决方法？">缓存雪崩的解决方法？</h3><p>事前：使得缓存高可用</p><p>事中：使用ehcache缓存部分数据，通过hystrix做限流&amp;降级，避免mysql崩溃</p><p>本地缓存的实时性怎么保证？</p><ul><li>引入消息队列，数据更新时通过订阅消息队列进行本地缓存同步更新</li><li>设置一个比较短的过期时间，定期从DB重新拉取</li></ul><p>事后：redis持久化，快速恢复缓存数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存与数据库双写数据一致性问题</title>
      <link href="/2021/08/03/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/03/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存与数据库双写数据一致性问题">缓存与数据库双写数据一致性问题</h1><p>本质上来说，双写一致性问题是因为更新数据库和更新缓存不是原子操作，如果要做到强一致性，只能加分布式锁。不然就是做取舍问题。</p><p>缓存是用在：不经常变动，但是又经常查询，而且发生脏读不敏感的场景下使用</p><p>缓存+数据库读写模式：</p><ol><li>cache aside pattern<ol><li>读的时候，先读缓存，缓存没有的话就读数据库，读到的数据库的值再存入缓存。</li><li>数据更新的时候，更新数据库，删除缓存。</li></ol></li><li>Read-Through/Write-Through（读写穿透）<ol><li>读写通过Cache Provider封装的api，Cache Provider进行缓存的读取和数据库的读取&amp;更新缓存，写的时候也是通过Provider进行。</li></ol></li><li>Write-behind（异步缓存写入）<ol><li>通过Cache Provider进行读写访问，Cache Provider在缓存层进行更新，不同步更新数据库，而是通过间隔一段时间批量异步更新数据库，如linux的os cache实现，写入之后定时进行fsync才会真正刷入磁盘</li></ol></li></ol><p><strong>如何解决双写数据一致性问题</strong><br>0. 读的时候，先读缓存，缓存没有的话就读数据库，读到的数据库的值再存入缓存，这种模式有极低的概率会导致不一致，可以给缓存设置一个过期时间，避免极少数key一直不一致</p><ol><li>强一致性情况下使用分布式事务对读写进行控制，但会降低并发量，没有什么意义。</li><li>弱一致性情况下使用延迟双删，更新数据库之前删除缓存，更新之后再延迟删除缓存，延迟的时间可以是读业务逻辑的耗时+几百毫秒</li><li>高并发读写的情况下，在一个修改请求删除了缓存之后，准备进行数据库更新，这时候有一个读请求进来，发现缓存为空，然后去数据库获取到旧值，保存到缓存中，然后修改请求修改数据库完成，这时候出现不一致问题<br>这时候可以考虑把缓存更新和读取操作进行异步串行化，将读写请求根据唯一标识进行路由，发送到一个内部队列中，</li><li>删除缓存重试机制</li><li>读取biglog异步删除缓存</li><li>写-延迟删缓存</li><li>消息队列异步更新缓存，注意带上时间戳避免并发写时顺序与写DB不一致</li></ol><p>整体来说还是需要结合实际项目，一致性和并发不能兼顾，具体情况具体分析了，如果是需要强一致性，其实缓存也就没有意义了，直接读库就行了…</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM HotSpot对象创建过程笔记</title>
      <link href="/2021/07/24/JVM-HotSpot%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/24/JVM-HotSpot%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-HotSpot对象创建">JVM HotSpot对象创建</h1><h3 id="创建方式">创建方式</h3><ul><li><p>new关键字</p></li><li><p>clone()：需要实现Cloneable接口</p></li><li><p>反序列化：需要实现Serializable 接口</p></li><li><p>反射</p><ul><li>Class.newInstance()方法</li><li>Class.getConstructors()方法</li></ul></li><li><p>Unsafe(sun.misc.Unsafe)：不需要调用其构造函数、初始化代码、JVM安全检查等</p><ul><li>allocateInstance()方法</li></ul><p>应用场景：</p><ul><li>java.lang.invoke</li><li>Gson的反序列化</li><li>Objenesis</li></ul></li></ul><h3 id="创建过程">创建过程</h3><ol><li><p>在常量池定位这个类的符号引用，符号引用代表的类是否被加载、解析、初始化过。若没有，则执行对应的类加载过程</p></li><li><p>确定对象所需内存，对象所需的内存在类加载完成后就能确定</p></li><li><p>分配内存</p><p>其中内存分配方法分为两种：</p><ol><li>指针碰撞（Bump the Point）：这个方法只有在GC算法有压缩整理功能才能使用，Java堆通过一个指针作为已使用内存和空闲内存的界限，分配内存就是把指针挪动需要的大小的距离</li><li>空闲列表（Free List）：通过把空闲的内存块通过列表记录起来，需要分配是在里面找到足够大的连续空间划分给对象实例</li></ol></li><li><p>内存初始化为零值</p><p>这个步骤若使用TLAB，则在TLAB分配时进行，具体是将数据类型设为对应的零值，如int的0，boolean的false</p></li><li><p>设置实例（markword）</p><ol><li>对象是哪个类的实例</li><li>类的元数据信息引用</li><li>对象的Hash Code：这个会在调用Object::hashCode()方法才会计算</li><li>GC分代信息</li></ol></li><li><p><init>方法初始化（构造函数）</init></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM锁类型笔记</title>
      <link href="/2021/07/03/JVM%E9%94%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/07/03/JVM%E9%94%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>之前在看JVM的锁优化中看到JVM中对synchronized实现中，在不同的情况下会对锁进行优化，其中有几种不同的锁实现，此篇做一个笔记，在这个月的月度分享中会将这篇分享到部门同事，共同进步~</p><h1 id="JVM锁类型">JVM锁类型</h1><p>对象头模型：</p><img src="/.io//07/03/JVM%E9%94%81%E7%B1%BB%E5%9E%8B/img1.png" class title="img1"><h3 id="轻量级锁">轻量级锁</h3><p>轻量级锁的“轻”是对比重量级锁来的，因为重量级锁需要对互斥量进行更新，操作更加消耗性能，而轻量级锁则是在此基础上继续优化，轻量级锁锁定不会去更新互斥量，而是会在调用这个对象的栈帧中，划出一个区域存放markword的部分信息，然后吧对象头的markword信息复制到这块空间中，然后对markword进行cas更新操作，如果成功则轻量级锁锁定成功。</p><p>基本前提就是线程间不会经常需要进行同步。</p><h3 id="重量级锁">重量级锁</h3><p>重量级锁需要MonitorObject，如轻量级锁膨胀的逻辑：</p><ol><li>先会去线程私有的monitor集合中获取，如果没有就去JVM全局的gFreeList中获取一个MonitorObject</li><li>初始化monitor对象</li><li>设置monitor的 header 字段为displaced mark word，owner 字段为Lock Record，obj 字段为锁对象</li><li>设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象</li></ol><h3 id="偏向锁">偏向锁</h3><p>偏向锁在轻量级锁的基础上，更加的“轻量”，因为markword大小的原因，它只在未计算出hashcode之前可以使用（需要JVM参数开启，jdk1.6+默认开启），具体过程是：</p><ol><li>对象在被线程获取到的时候，如果可以偏向，先会将线程ID写入markword中，并将状态设为01，可偏向状态设为1。</li><li>之后如果需要同步，只需要检查markword就可以判断是否还是当前线程偏向，不需要额外的膨胀操作。</li><li>如果有其他线程请求同一个对象的锁，这时候就会进行锁膨胀，为轻量级锁。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM双亲委派模型笔记</title>
      <link href="/2021/06/27/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/27/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>上次学习了JVM的类加载过程，之前学习过的双亲委派模型变得生疏了，这篇笔记用于重新学习和以后复习~</p><h1 id="JVM双亲委派模型">JVM双亲委派模型</h1><h3 id="什么是双亲委派模型？">什么是双亲委派模型？</h3><p>在加载一个类之前，先使用父加载器加载，若返回null才进行加载。</p><p>引入双亲委派模型是为了解决一些核心类，只能由某个加载器进行加载，避免有全限名一样但类加载器不一样的情况。</p><h3 id="类的唯一标识是什么？">类的唯一标识是什么？</h3><p>加载类的类加载器+类全限名</p><h3 id="双亲委派模型的破坏">双亲委派模型的破坏</h3><ol><li>jdk1.2，双亲委派模型出现时需要对旧类加载逻辑进行兼容，加入了findClass()方法，使得可以通过重写findClass()方法进行破坏</li><li>jdk中定义好的标准（SPI），但需要外部jar包进行实现的，如JDBC，需要父加载器指定子加载器进行加载，破坏了双亲委派模型</li><li>热部署，热加载</li></ol><h3 id="类加载器类型">类加载器类型</h3><ol><li>BootStrap ClassLoader：&lt;JAVA_HOME&gt;\lib</li><li>Extension ClassLoader：&lt;JAVA_HOME&gt;\lib\ext</li><li>Application ClassLoader：ClassPath</li><li>User ClassLoader</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载过程学习笔记</title>
      <link href="/2021/06/20/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/20/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM类加载过程">JVM类加载过程</h1><h3 id="什么是类加载？">什么是类加载？</h3><p>在代码编译后，就会生成JVM（Java虚拟机）能够识别的二进制字节流文件（*.class）。而JVM把Class文件中的类描述数据从文件加载到内存，并对数据进行校验、转换解析、初始化，使这些数据最终成为可以被JVM直接使用的Java类型，这个说来简单但实际复杂的过程叫做JVM的类加载机制。</p><h3 id="类加载过程分别是什么？">类加载过程分别是什么？</h3><p><img src="/.io//Untitled.png" alt="Untitled"></p><ol><li><p>Class类文件加载</p><p>首先类加载器通过一个类的全限定名获取此类的二进制字节流，将字节流中的静态存储结构转化为运行时方法区的数据结构，然后在内存中生成该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口，就完成了Class类文件的加载</p></li><li><p>验证</p><p>首先会检查二进制字节流合法性</p><p>然后校验类型：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证：检查局部变量表中slot是否越界使用</li><li>符号引用验证：符号引用校验发生在解析阶段，符号引用可以看做是类自身以外的的信息进行匹配性校验，其中包含了验证符号引用中的全限定名能否找到对应的类、验证指定类中是否有存在符号方法的字段描述符，以及简单名称所描述的方法和字段、验证符号引用中的类、字段、方法的访问性，能否被当前类访问</li></ul></li><li><p>准备</p><p>首先为对象分配内存，然后设置类变量初始值，如int的0，boolean的false，若字段表中存在的ConstantValue，则对应的变量会提前初始化为设定值（若为final变量，提前读取常量池获取值）</p></li><li><p>解析</p><p>将符号引用转化为直接引用</p></li><li><p>初始化</p><p>触发类初始化的场景：</p><ul><li>遇到new、getstatic、setstatic、invokestatic，这四条字节码指令，如果类没有初始化，则要先触发初始化。使用new关键字、读取或设置一个类的静态字段（被final修饰、已在编译期就把结果放入常量池的静态字段除外），以及调用静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候</li><li>初始化一个类的时候，如果父类还没有初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，用户指定的主类需要先初始化</li><li>使用JDK1.7的动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄的对应的类没有初始化，需要触发其初始化</li></ul><p>什么情况下不会触发初始化？</p><ul><li>调用父类的static域的变量、方法，不会触发子类的初始化</li><li>创建一个类的数组，不会触发初始化</li><li>编译阶段的常量传播优化：在常量在编译阶段会存入调用类的常量池中</li></ul></li><li><p>使用</p><p>我们在代码中声明创建之后，进行使用</p></li><li><p>卸载</p><p>卸载分为两种情况：</p><ol><li>jvm自带的类加载器：由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。前面已经介绍过，Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。</li><li>用户自定义的类加载器：由用户自定义的类加载器所加载的类是可以被卸载的</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本调优参数</title>
      <link href="/2021/06/15/JVM%E5%9F%BA%E6%9C%AC%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/"/>
      <url>/2021/06/15/JVM%E5%9F%BA%E6%9C%AC%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="指定堆大小">指定堆大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定堆最大</span></span><br><span class="line">-XX:Xmx1024m</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定堆初始大小</span></span><br><span class="line">-XX:Xms1024m</span><br></pre></td></tr></table></figure><h3 id="Java方法栈">Java方法栈</h3><p>指定线程的栈最大空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认256K</span></span><br><span class="line">-XX:Xss128K</span><br></pre></td></tr></table></figure><p>影响GC因素：</p><p>局部变量表槽位复用</p><p>在方法体中声明的变量都会在局部变量表中，如果超过其作用域，则会被之后声明的变量复用，如果是引用类型，则会失去引用，被GC。但如果只是超过作用域但是没有被其他变量复用，则不会失去引用。</p><p>栈内分配</p><p>逃逸分析</p><p>用于分析引用类型声明的变量的作用域是否会逃逸出方法体，如果作用域只在方法体内且不返回，则可以标量替换</p><p>标量替换</p><p>指类引用类型声明时，如果可以被</p><p>TLAB</p><p>TLAB（Thread Local Allocation Buffer）本地线程分配缓存，在类加载之后分配内存时，如果开启了这个选项，则可以在堆中属于线程的缓存区分配内存，不需要到共享的堆区进行内存申请，避免内存申请失败。开启了这个会使得栈内分配失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启TLAB</span></span><br><span class="line">-XX:+UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">-XX:-UseTLAB</span><br></pre></td></tr></table></figure><h3 id="永久代-元空间">永久代&amp;元空间</h3><p>永久代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定永久代初始大小</span></span><br><span class="line">-XX:PermSize64m</span><br><span class="line"><span class="comment">//指定最大永久代大小</span></span><br><span class="line">-XX:MaxPermSize128m</span><br></pre></td></tr></table></figure><p>元空间</p><p>元空间使用的是直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定元空间最大大小，默认无限制直到用光系统内存</span></span><br><span class="line">-XX:MaxMetaspaceSize512m</span><br></pre></td></tr></table></figure><h3 id="打印GC日志">打印GC日志</h3><p>jdk9之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印简单GC日志</span></span><br><span class="line">-XX:+PrintGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印GC日志详情</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取堆信息</span></span><br><span class="line">-XX:+PrintHeadAtGC</span><br></pre></td></tr></table></figure><p>jdk9、jdk10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印简单日志</span></span><br><span class="line">-Xlog:gc</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日志详情</span></span><br><span class="line">-Xlog:gc*</span><br></pre></td></tr></table></figure><h3 id="GC日志查看">GC日志查看</h3><p>注意：因为GC日志输出时机的原因，显示的数据可能并不准确，有问题的地方需要重新校对</p><p><code>DefNew</code> ：新生代</p><p><code>eden</code> 、 <code>from</code> 、 <code>to</code></p><p><code>Tenured</code> ：老年代</p><p><code>Perm</code> ：永久代</p><h3 id="类加载-卸载追踪">类加载/卸载追踪</h3><p>jdk9之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure><p>jdk9、jdk10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:<span class="class"><span class="keyword">class</span>+<span class="title">load</span></span>=info</span><br></pre></td></tr></table></figure><h3 id="柱状图分析">柱状图分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配合在控制台使用ctrl+Break展示信息</span></span><br><span class="line">-XX:+PrintClassHistogram</span><br></pre></td></tr></table></figure><h3 id="查看系统参数">查看系统参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行时展示手动配置的参数</span></span><br><span class="line">-XX:+PrintVMOptions</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动配置&amp;手动配置的参数都展示</span></span><br><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure><h3 id="指定堆大小-2">指定堆大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定堆最大</span></span><br><span class="line">-XX:Xmx1024m</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定堆初始大小</span></span><br><span class="line">-XX:Xms1024m</span><br></pre></td></tr></table></figure><h3 id="Java方法栈-2">Java方法栈</h3><p>指定线程的栈最大空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认256K</span></span><br><span class="line">-XX:Xss128K</span><br></pre></td></tr></table></figure><p>影响GC因素：</p><p>局部变量表槽位复用</p><p>在方法体中声明的变量都会在局部变量表中，如果超过其作用域，则会被之后声明的变量复用，如果是引用类型，则会失去引用，被GC。但如果只是超过作用域但是没有被其他变量复用，则不会失去引用。</p><p>栈内分配</p><p>逃逸分析</p><p>用于分析引用类型声明的变量的作用域是否会逃逸出方法体，如果作用域只在方法体内且不返回，则可以标量替换</p><p>标量替换</p><p>指类引用类型声明时，如果可以被</p><p>TLAB</p><p>TLAB（Thread Local Allocation Buffer）本地线程分配缓存，在类加载之后分配内存时，如果开启了这个选项，则可以在堆中属于线程的缓存区分配内存，不需要到共享的堆区进行内存申请，避免内存申请失败。开启了这个会使得栈内分配失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启TLAB</span></span><br><span class="line">-XX:+UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">-XX:-UseTLAB</span><br></pre></td></tr></table></figure><h3 id="永久代-元空间-2">永久代&amp;元空间</h3><p>永久代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定永久代初始大小</span></span><br><span class="line">-XX:PermSize64m</span><br><span class="line"><span class="comment">//指定最大永久代大小</span></span><br><span class="line">-XX:MaxPermSize128m</span><br></pre></td></tr></table></figure><p>元空间</p><p>元空间使用的是直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定元空间最大大小，默认无限制直到用光系统内存</span></span><br><span class="line">-XX:MaxMetaspaceSize512m</span><br></pre></td></tr></table></figure><h3 id="打印GC日志-2">打印GC日志</h3><p>jdk9之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印简单GC日志</span></span><br><span class="line">-XX:+PrintGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印GC日志详情</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取堆信息</span></span><br><span class="line">-XX:+PrintHeadAtGC</span><br></pre></td></tr></table></figure><p>jdk9、jdk10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印简单日志</span></span><br><span class="line">-Xlog:gc</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日志详情</span></span><br><span class="line">-Xlog:gc*</span><br></pre></td></tr></table></figure><h3 id="GC日志查看-2">GC日志查看</h3><p>注意：因为GC日志输出时机的原因，显示的数据可能并不准确，有问题的地方需要重新校对</p><p><code>DefNew</code> ：新生代</p><p><code>eden</code> 、 <code>from</code> 、 <code>to</code></p><p><code>Tenured</code> ：老年代</p><p><code>Perm</code> ：永久代</p><h3 id="类加载-卸载追踪-2">类加载/卸载追踪</h3><p>jdk9之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure><p>jdk9、jdk10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:<span class="class"><span class="keyword">class</span>+<span class="title">load</span></span>=info</span><br></pre></td></tr></table></figure><h3 id="柱状图分析-2">柱状图分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配合在控制台使用ctrl+Break展示信息</span></span><br><span class="line">-XX:+PrintClassHistogram</span><br></pre></td></tr></table></figure><h3 id="查看系统参数-2">查看系统参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行时展示手动配置的参数</span></span><br><span class="line">-XX:+PrintVMOptions</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动配置&amp;手动配置的参数都展示</span></span><br><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot启动过程笔记</title>
      <link href="/2021/05/21/Springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/21/Springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>之前看了springIOC源码，现在结合Springboot整体启动过程来看这个</p><h3 id="重要的时间回调机制">重要的时间回调机制</h3><p><code>ApplicationContextInitializer</code></p><p>上下文初始化器，在创建出上下文之后被执行</p><p><code>SpringApplicationRunListener</code></p><p>应用启动监听器，在各个阶段的方法，在spring启动到指定时期回调</p><p><code>ApplicationRunner</code></p><p><code>CommandLineRunner</code></p><p>用于自定义创建IOC容器完成后的操作，入参是命令行参数</p><h3 id="自定义回调机制">自定义回调机制</h3><p><code>ApplicationContextInitializer</code> 、<code>SpringApplicationRunListener</code> 自定义需要在当前项目下的 <code>META-INF/spring.factories</code> 配置文件中加入自定义的实现类</p><p>关键类：</p><p><code>SpringApplication</code> ：应用</p><p><code>SpringApplicationContext</code> ：应用上下文</p><p><code>SpringApplicationRunListener</code> ：应用运行监听器</p><p>启动步骤：</p><ol><li><p>调用<code>SpringApplication</code> 的静态方法 <code>run</code> 方法</p></li><li><p><code>run</code> 方法创建 <code>SpringApplication</code> 实例，这里用到了工厂模式，并通过 <code>initialize</code> 方法初始化，其中从<code>META-INF/spring.factories</code> 中获取 <code>ApplicationContextInitializer</code> 应用上下文初始化器的子类全限名，然后通过ClassLoader实例化，获取到的初始化器列表存储起来，然后通过同样的方法实例化监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否web环境</span></span><br><span class="line"><span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line"><span class="comment">//存储实例化的初始化器列表</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="comment">//存储实例化的监听器列表</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后通过实例方法 <code>run</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 从META-INF/spring.factories获取 SpringApplicationRunListeners </span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">// 把所有的Listeners都启动</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 封装命令行参数</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line"><span class="comment">// 准备环境，激活哪个profile在这里读取，</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line"><span class="comment">// 打印横幅图标</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line"><span class="comment">// 判断是否web环境，然后通过反射创建IOC容器</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line"><span class="comment">// 异常分析报告</span></span><br><span class="line">analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line"><span class="comment">// 准备上下文环境，把environment设进context，然后获取之前保存的初始化器，</span></span><br><span class="line"><span class="comment">// 调用初始化器的initialize()方法对context进行初始化，初始化完成之后，</span></span><br><span class="line"><span class="comment">// 回调SpringApplicationRunListener监听器</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line"><span class="comment">// 刷新（初始化）容器，加载IOC容器所有配置的组件，如果是web应用还会创建内置tomcat</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// 从IOC容器中获取所有ApplicationRunner.class 、CommandLineRunner.class</span></span><br><span class="line"><span class="comment">// 优先调用前一个回调，再回调另一个</span></span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line"><span class="comment">// 所有的ApplicationRunListener回调finished()方法</span></span><br><span class="line">listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回上下文</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prepareContext()</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line"><span class="comment">//把environment保存入context，如默认profile和激活profile等</span></span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line"><span class="comment">//对context进行</span></span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册命令行参数到springApplicationArguments单例实例</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">applicationArguments);</span><br><span class="line"><span class="comment">//注册横幅到springBootBanner单例实例</span></span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取springboot入口类</span></span><br><span class="line">Set&lt;Object&gt; sources = getSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[sources.size()]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP源码学习笔记</title>
      <link href="/2021/05/05/SpringAOP%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/05/SpringAOP%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringAOP是什么">SpringAOP是什么</h3><p>springAOP是Spring框架对aop切面编程模式的一个实现，具体来说就是通过BeanPostProcessor在SpringIOC的支持下，在Bean初始化时进行的增强。具体流程可以看我之前写的SpringIOC源码笔记。</p><h3 id="基于Spring1-2的aop支持：">基于Spring1.2的aop支持：</h3><img src="/.io//05/05/SpringAOP%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img1.png" class title="img1"><p>通过 <code>DefaultAdvisorAutoProxyCreator</code> 实现的，创建Bean过程的初始化 <code>AbstractAutowireCapableBeanFactory#doCreateBean();</code> 中的 <code>initializeBean()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 1. 执行每一个 BeanPostProcessor 的 postProcessBeforeInitialization 方法</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 bean 配置中的 init-method="xxx"</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 关注的重点是这</span></span><br><span class="line">      <span class="comment">// 2. 执行每一个 BeanPostProcessor 的 postProcessAfterInitialization 方法</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会执行每一个 <code>BeanPostProcessor</code> ，也就是AOP的实现类 <code>DefaultAdvisorAutoProxyCreator</code> 会在这里被调用并返回代理类。</p><p><code>DefaultAdvisorAutoProxyCreator</code> 的逻辑是对每一个需要增强的bean进行解析，把代理信息封装为 <code>ProxyFactory</code> ，然后调用 <code>getProxy()</code> 获取代理类。</p><p>其中 <code>ProxyFactory</code> 是通过被代理类是否可以使用jdk动态代理，如果可以则返回 <code>JdkDynamicAopProxy</code> ，否则就返回GCLIB的动态代理实现类 <code>ObjenesisCglibAopProxy</code> ，然后通过具体的实现类调用 <code>getProxy()</code> 生成代理类</p><h3 id="基于Spring2-0的AspectJAOP支持：">基于Spring2.0的AspectJAOP支持：</h3><img src="/.io//05/05/SpringAOP%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img2.png" class title="img2">]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC源码学习笔记</title>
      <link href="/2021/05/03/SpringIOC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/03/SpringIOC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>趁着五一假期深入学习一下SpringIOC构建的源码，获益匪浅~</p><h2 id="ApplicationContext">ApplicationContext</h2><p>IOC容器是基于 <code>应用上下文类</code> 的子类，因为这个类继承了 <code>ListableBeanFactory</code>  可列表BeanFactory和 <code>HierarchicalBeanFactory</code> 分层BeanFactory ，这两个类继承于 <code>BeanFactory</code> ，然后通过组合的方式把 <code>AutowireCapableBeanFactory</code> 组合进去了，用来支撑DI功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 刷新上下文准备：记录开始时间，设置运行标识</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁旧BeanFactory，新建一个新的BeanFactory，并把配置中的bean转化为BeanDefinition</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化单例bean（非懒加载）</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法 <code>refresh()</code></p><ol><li>给方法上锁，避免在刷新上下文期间重复调用</li><li>销毁旧BeanFactory，新建一个新的BeanFactory，并把配置中的bean转化为BeanDefinition<ol><li>读取xml中的配置的 <code>&lt;bean /&gt;</code> 标签配置转换为 <code>BeanDefinition</code> 然后把 <code>BeanDefinition</code> 注册到注册中心，并发送注册事件。</li><li>说到底核心是一个 beanName-&gt; beanDefinition 的 map</li></ol></li><li>设置BeanFactory的类加载器，手动注册几个特殊类，注册BeanPostProcessor</li><li>回调BeanFactoryPost类</li><li>实例化非懒加载的单例Bean  <code>finishBeanFactoryInitialization(beanFactory);</code><ol><li>手动加载 <code>conversionService</code> 用于类型转换，如controller中入参的转换</li><li><code>preInstantiateSingletons()</code> ：初始化/预初始化单例bean<ol><li>获取所有beanDefinition的在map中的name</li><li>分别加载 <code>FactoryBean</code> 和普通单例bean，分别调用  <code>AbstractBeanFactory</code> 的 <code>getBean()</code> 方法进行初始化 ：<ol><li>传入的beanName在别名map中找直到找到正式名称</li><li>获取已经创建完成的缓存了的对象，通过正式名称查询是否已经创建完成或者正在创建，如果正在创建在 <code>earlySingletonObjects</code> 早期单例map缓存中获取，如果没有则创建一个早期对象，并add进 <code>earlySingletonObjects</code> 。如果找到了这个对象，则直接返回这个对象，不需要再创建了</li><li>获取当前单例对象的 <code>beanDefinition</code> ，如果在当前上下文找不到，就到父容器中找 ：找不到这个单例对象，说明还没有初始化，现在开始初始化</li><li>合并拥有父子关系的 <code>bean</code> 对应的 <code>beanDefinition</code></li><li>检查 <code>bean</code> 的 <code>dependsOn</code> 属性，避免在这里循环依赖，并把依赖到的 <code>bean</code> 先初始化</li><li>通过自定义的 <code>ObjectFactory</code> 进行创建单例实例，如果是 <code>FactoryBean</code> 还需要多做一步通过这个工厂类创建对应的单例实例 , 核心方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBean(beanName, mbd, args);</code><ol><li><p>判断是否需要方法重写，如定义了 <code>lookup-method</code> 或 <code>replace-method</code> ，需要经过CGLIB生成新的类</p></li><li><p>判断是否有代理类需要对 <code>bean</code> 进行增强 <code>InstantiationAwareBeanPostProcessor</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br></pre></td></tr></table></figure></li><li><p>对 <code>bean</code> 进行创建 <code>doCreateBean(beanName, mbdToUse, args)</code></p><ol><li><p>判断是否是 <code>FactoryBean</code> ，如果不是就实例化 <code>bean</code> ，如果是，则通过这个工厂类创建对应的单例</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure><ol><li>确保已经加载了此 class</li><li>校验一下这个类的访问权限</li><li>看下是否配置了 <code>factory-method</code> ，如果有则采用工厂方法实例化</li><li>判断是用 <code>无参构造</code> 还是 <code>构造函数依赖注入</code> ，使用对应的构造方法</li></ol></li><li><p>解决循环依赖问题</p></li><li><p>装配成员变量 <code>populateBean(beanName, mbd, instanceWrapper);</code></p><ol><li>区分通过名称还是类型进行注入：<ol><li>通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</li><li>通过类型装配。复杂一些</li></ol></li><li>对采用 @Autowired、@Value 注解的依赖进行设值到 <code>PropertyValues</code></li><li>通过配置好的 <code>PropertyValues</code>  对象对 <code>bean</code> 进行设值</li></ol></li><li><p>初始化 <code>bean</code> ：<code>initializeBean(beanName, exposedObject, mbd);</code></p><ol><li>如果 bean 实现了 <code>BeanNameAware</code> 、 <code>BeanClassLoaderAware</code> 或  <code>BeanFactoryAware</code>  接口，回调</li><li><code>BeanPostProcessor</code>  的  <code>postProcessBeforeInitialization()</code> 回调</li><li>处理 bean 中定义的  <code>init-method</code> ，或者如果 bean 实现了  <code>InitializingBean</code>  接口，调用  <code>afterPropertiesSet()</code>  方法</li><li><code>BeanPostProcessor</code>  的  <code>postProcessAfterInitialization</code>  回调，<strong>aop在这里做增强</strong></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring拦截器和过滤器</title>
      <link href="/2021/03/13/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2021/03/13/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>贴一下以前做的spring笔记，提供给大家学习~</p><h1 id="Spring-Interceptor-Filter">Spring Interceptor&amp;Filter</h1><h3 id="Interceptor（拦截器）">Interceptor（拦截器）</h3><p>需要Springmvc支持，通过实现 <code>HandlerInterceptor</code> 接口，并在 <code>WebMvcConfigurerAdapter</code> 中 <code>addInterceptors</code> 注册拦截器绑定拦截路径实现对 <code>Controller</code> 的围绕通知或者拦截，比如判断用户登录情况、权限验证。</p><p>其中 <code>preHandle()</code> 方法在调用Handler之前进行拦截(下图步骤3)， <code>postHandle()</code>方法在视图渲染之前调用(下图步骤5)， <code>afterCompletion()</code> 方法在返回相应之前执行</p><img src="/.io//03/13/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/img1.png" class title="img1"><p><strong>多个拦截器的执行顺序</strong></p><p>多个拦截器它的执行顺序是和栈的入栈出栈顺序有点类似，我们把preHandle方法比作入栈，postHandle方法比作出栈，所以就是preHandle先执行的postHandle反而后执行。</p><img src="/.io//03/13/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/img2.png" class title="img2"><h3 id="Filter（过滤器）">Filter（过滤器）</h3><p>通常用于过滤字符编码、做一些业务逻辑判断，主要用于对用户请求进行预处理，同时也可进行逻辑判断。Filter不依赖与Springmvc，只需要依赖servlet，Filter随着Web应用启动。Filter是链式调用。</p><p>通过实现 <code>Filter</code> 接口，并在web配置中加入 <code>FilterRegistrationBean</code> 的Bean中进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogCostFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">"Execute cost="</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> LogCostFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        registration.setName(<span class="string">"LogCostFilter"</span>);</span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Filter和Interceptor的区别</strong></p><ol><li>Filter是基于函数回调（doFilter()方法）的，而Interceptor则是基于Java反射的（AOP思想）。</li><li>Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器。</li><li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li><li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li><li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li><li>Filter在过滤是只能对request和response进行操作，而interceptor可以对request、response、handler、modelAndView、exception进行操作。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令笔记</title>
      <link href="/2021/02/21/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/21/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令汇总">Git常用命令汇总</h1><h3 id="添加个人信息">添加个人信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">projectPath/.git/config 添加</span><br><span class="line">[user]</span><br><span class="line">        email=chingguo20@<span class="number">163</span>.com</span><br><span class="line">        name=ching</span><br></pre></td></tr></table></figure><h3 id="ssh秘钥生成">ssh秘钥生成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure><h3 id="分支">分支</h3><h3 id="查看分支">查看分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a &#x2F;&#x2F;查看所有分支（远程和本地）</span><br></pre></td></tr></table></figure><h3 id="分支修改暂存-恢复">分支修改暂存&amp;恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash&#x2F;&#x2F;将当前分支修改的暂存</span><br><span class="line">git checkout dev&#x2F;&#x2F;切换到目标分支</span><br><span class="line">git stash pop&#x2F;&#x2F;恢复暂存到目标分支</span><br></pre></td></tr></table></figure><h3 id="分支的追踪">分支的追踪</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;&#39;远程分支&#39; &#39;本地分支&#39;  &#x2F;&#x2F;设置一个分支的追踪远程分支</span><br><span class="line">git checkout -b &#39;本地分支&#39; &#39;远程分支&#39; &#x2F;&#x2F;创建一个分支并绑定远程分支</span><br></pre></td></tr></table></figure><h3 id="设置追踪仓库">设置追踪仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br></pre></td></tr></table></figure><h3 id="创建远程分支">创建远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newBranch</span><br></pre></td></tr></table></figure><h3 id="分支push需要回滚时">分支push需要回滚时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一（不会删除提交历史记录，会新建一个提交作为回滚）</span><br><span class="line"> git revert HEAD</span><br><span class="line"> git push origin master</span><br><span class="line">&#x2F;&#x2F;方法二（会删除历史记录）</span><br><span class="line"> git reset --hard HEAD^ </span><br><span class="line"> git push origin master -f</span><br></pre></td></tr></table></figure><h3 id="还原已回滚的分支">还原已回滚的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog&#x2F;&#x2F;查看所有分支的所有操作记录</span><br><span class="line">git reset --soft HEAD^&#x2F;&#x2F;撤销一次commit，保留更改代码</span><br><span class="line">git reset --hard &quot;版本号&quot; &#x2F;&#x2F;还原分支</span><br></pre></td></tr></table></figure><h3 id="Merge">Merge</h3><h3 id="放弃merge操作">放弃merge操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --merge</span><br></pre></td></tr></table></figure><h3 id="将dev中的更改merge到master">将dev中的更改merge到master</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master&#x2F;&#x2F; 将分支切换到merge</span><br><span class="line">git merge dev&#x2F;&#x2F;执行merge</span><br></pre></td></tr></table></figure><h3 id="选择合并commit">选择合并commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &#123;logNum&#125;</span><br></pre></td></tr></table></figure><h3 id="设置新远程仓库">设置新远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> git remote set-url origin [new Origin]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot自定义Starter</title>
      <link href="/2021/02/13/Springboot%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"/>
      <url>/2021/02/13/Springboot%E8%87%AA%E5%AE%9A%E4%B9%89Starter/</url>
      
        <content type="html"><![CDATA[<p>明天虽然没有女朋友要陪，但是工作还是要做好的~，项目需要自定义Starter对新功能进行支持，虽然之前也做过，但是没有系统性分析其原理，所以这两天对Spring自定义Starter进行深入学习，做了以下笔记，提供给大家学习。</p><h1 id="Springboot自定义Starters">Springboot自定义Starters</h1><h3 id="关键点">关键点</h3><ol><li><p>编写pom文件，引入相关依赖</p></li><li><p>编写XXXAutoConfiguration类实现自动配置</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定条件下成立的时候自动配置生效</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给容器中添加组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定配置文件中到属性配置类</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载属性配置类到容器，相当于用@Bean加载属性配置类，这个注解简化了流程</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br></pre></td></tr></table></figure></li><li><p>编写 <code>META-INF/spring.factories</code> 文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">xxx.xxx.XXXAutoConfiguration</span><br></pre></td></tr></table></figure></li><li><p>模式：</p><ul><li>启动器只用来做依赖导入</li><li>另外写一个自动配置模块，与启动器解耦</li><li>启动器依赖自动配置，使用时引入启动器</li></ul></li><li><p>命名：</p><ul><li>官方命名模式： <code>spring-boot-starter-xxx</code></li><li>自定义starter命名： <code>xxx-spring-boot-starter</code></li></ul></li></ol><h3 id="自定义Starter流程">自定义Starter流程</h3><ol><li>创建空项目</li><li>空项目中新增模块（Maven项目）作为启动starter</li><li>空项目中新增模块（Spring项目）作为自动配置starter</li><li>启动starter引入自动配置starter依赖</li><li>自动配置starter编写<ol><li>新增xxxProperties配置类，与配置文件做绑定</li><li>编写starter实现的功能</li><li>编写xxxAutoConfiguration类进行自动配置，在里面把实现的功能注入IOC容器</li><li>编写 <code>META-INF/spring.factories</code> 文件，把xxxAutoConfiguration配置进去</li><li>打包，先打包自动配置starter，再打包启动starter</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码学习笔记</title>
      <link href="/2020/09/16/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/09/16/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap源码学习笔记">HashMap源码学习笔记</h2><h3 id="HashMap核心属性解析">HashMap核心属性解析</h3><h4 id="DEFAULT-INITIAL-CAPACITY（默认初始容量）">DEFAULT_INITIAL_CAPACITY（默认初始容量）</h4><p>默认初始容量是在构造HashMap时，不定义初始容量默认指定的大小，默认大小为1&lt;&lt;4也就是16；</p><h4 id="MAXIMUM-CAPACITY（最大容量）">MAXIMUM_CAPACITY（最大容量）</h4><p>最大容量是单个HashMap实例所能装载的最大容量，值为1&lt;&lt;30，也就是536,870,912个元素；</p><h4 id="DEFAULT-LOAD-FACTOR（默认装载因子）">DEFAULT_LOAD_FACTOR（默认装载因子）</h4><p>默认装载因子，在构造HashMap时，不指定装载因子时，默认为0.75f。装载因子的作用是留一部分的容量作为冗余，避免hash之后过多元素分配到一个桶里，导致hashmap退化成链表。</p><h4 id="MIN-TREEIFY-CAPACITY（最小树化容量阈值）">MIN_TREEIFY_CAPACITY（最小树化容量阈值）</h4><p>最小树化阈值是jdk1.8中加入的，控制HashMap在什么情况下会将桶中的链表转为红黑树，默认为64</p><h4 id="TREEIFY-THRESHOLD（树化阈值）">TREEIFY_THRESHOLD（树化阈值）</h4><p>树化阈值是在jdk1.8中被加入的，默认为8，应用在我们常听说的红黑树中，在HashMap实例的元素数量大于最小化树化阈值且大于树化阈值时，就会将链表转为红黑树。</p><h4 id="UNTREEIFY-THRESHOLD（链表化阈值）">UNTREEIFY_THRESHOLD（链表化阈值）</h4><p>链表化阈值是jdk1.8中被加入，默认为6，之所以不与树化阈值相等，是为了在同一桶中的元素增删时不会导致频繁树化和链表化。</p><h3 id="HashMap核心方法解析">HashMap核心方法解析</h3><h4 id="hash">hash()</h4><p>这是hashmap核心的方法之一，也是HashMap中的“Hash”的体现，其中进行了一次hash计算和<strong>对hash值进行和高16位进行异或计算</strong>,也就是其中的 <strong>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</strong> ,hash方法之所以要这样“多此一举”，目的是为了在使用hash值进行映射时避免与运算丢失高位特征，以保障元素趋于平均分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="putVal">putVal()</h3><p>这是hashmap的put()方法中最终调用的方法，也是添加元素功能的实现方法；其中hashmap采用了lazy-load的思想，构造HashMap实例时并不会对内部数组进行初始化，而是在首次put的时候才进行。<br>其中逻辑：</p><ol><li>判断是否需要初始化，若需要初始化则调用<strong>resize()</strong> 方法，并返回初始化的容量大小。</li><li>进行hash()计算，通过与运算获取元素实际插入的下标，判断下标中的桶空间是否有节点，若没有节点则新建node节点，进入<strong>5</strong>，否则进入<strong>3</strong>流程。</li><li>获取对应桶空间的第一个节点，判断是树节点还是普通节点，若为树节点，则调用<strong>putTreeVal()</strong> 方法插入树，否则新建一个普通节点，并循环找到链表中最后一个节点并判断元素是否存在，若存在则跳转到<strong>4</strong>；找到链表末尾，将新节点插入到最后一个节点后，判断是否需要树化，若需要树化则调用<strong>treeifyBin()</strong> 方法进行树化。</li><li>判断在步骤3中是否插入了节点，若无插入新节点，则返回旧值，结束插入逻辑。</li><li>hashMap实例的size属性加1，并判断是否需要扩容，若需要扩容则执行<strong>resize()</strong> 方法</li><li>返回null;</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重温TCP——从状态机状态转移开始</title>
      <link href="/2020/08/31/%E9%87%8D%E6%B8%A9TCP%E2%80%94%E2%80%94%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%BC%80%E5%A7%8B/"/>
      <url>/2020/08/31/%E9%87%8D%E6%B8%A9TCP%E2%80%94%E2%80%94%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的概念</title>
      <link href="/2020/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式概念">设计模式概念</h2><h3 id="0-设计模式产生的背景">0. 设计模式产生的背景</h3><p>“设计模式”最开始是在建筑设计领域被提出的，其对城镇、邻里、住宅、花园和房间等进行设计的基本模式，提供了一些建筑设计中常见问题的解决方法。<br>而在之后，软件开发中的“设计模式”才被提出，并在1995年，多名作者合作出版的《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书中提出了23中设计模式，首次将软件设计模式进行具体定义和分类。</p><h3 id="1-什么是设计模式">1. 什么是设计模式</h3><p>软件设计模式（Software Design Pattern），简称设计模式，是一套被反复使用，分类的代码编程经验的总结。它将软件设计过程中一些重复的问题的解决方法抽象出来，归纳为一系列的解决方法。可以提高代码的可重用性，可读性和可靠性。<br>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><h3 id="2-学习设计模式的意义">2. 学习设计模式的意义</h3><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="软件设计模式的基本要素">软件设计模式的基本要素</h2><ol><li>模式名(Pattern Name)</li></ol><p>每个模式根据特点、所解决的问题、功能等属性进行命名。模式名称帮助我们记忆和实际软件设计过程中的交流。</p><ol start="2"><li>问题(Problem)</li></ol><p>问题描述了何时使用该模式，以及使用该模式的一些先决条件。</p><ol start="3"><li>解决方案(Solution)</li></ol><p>模式问题的解决方案包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。设计模式是一个模板，解决方案是通常是以类图形式展示，是对需要解决的问题的解决方案的抽象。</p><ol start="4"><li>效果(Consequence)</li></ol><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的交换机类型</title>
      <link href="/2020/07/21/RabbitMQ%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/07/21/RabbitMQ%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ的交换机类型">RabbitMQ的交换机类型</h1><h2 id="fanout">fanout</h2><p>路由到与该交换机绑定的<strong>所有队列</strong>中去</p><h2 id="direct">direct</h2><p>路由到<strong>BindingKey和Routingkey相同的队列</strong>中去</p><h2 id="topic">topic</h2><ul><li><p>路由到<strong>BingdingKey和RoutingKey匹配的队列</strong>中去</p></li><li><p>匹配规则</p><ul><li>RoutingKey是以“.”分隔的字符串</li><li>BindingKey也是以“.”分隔的字符串</li><li>BindingKey中可以使用“*”和“#”两个符号进行模糊匹配，“*”匹配一个字符，“#”匹配零或多个字符</li></ul></li></ul><h2 id="headers">headers</h2><p>该类型不依赖路由键匹配来路由，而是根据发送的消息中的headers属性（键值对）进行匹配，在绑定队列和交换机时指定一组键值对，headers属性和指定的键值对进行匹配，键值对完全匹配则进行路由</p>]]></content>
      
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的线程安全和锁优化</title>
      <link href="/2020/07/21/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>/2020/07/21/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的线程安全和锁优化">Java的线程安全和锁优化</h1><h2 id="线程安全">线程安全</h2><p>在Java中或者说在Jvm实现中，线程安全是一个相对的概念，某个对象在单独使用某个操作时是线程安全的，但在某些操作顺序却不是线程安全，需要额外的同步。该节将介绍线程安全的概念和在Java中的实现。</p><h3 id="Java语言中的线程安全">Java语言中的线程安全</h3><h4 id="不可变">不可变</h4><p>final类型的基本类型，在初始化时，如果没有发生this引用逃逸正确地初始化，在以后的使用中值不会变更，是线程安全的；对象行为不会对自身状态变更的对象，所有的行为都不会对自身进行变更，如java.lang.String类，subString()、trim()等方法都是返回一个目标值而对自身的变量不进行变更，也是线程安全的。</p><h4 id="绝对线程安全">绝对线程安全</h4><p>不需要做任何额外的同步，在多线程环境中都能得到正确的结果的变量，实际上这种要求很严苛，因为就算是“线程安全”的类，在某些操作顺序中也会导致不正确的结果，而需要额外的同步块进行同步控制。</p><h4 id="相对线程安全">相对线程安全</h4><p>对象的单独调用时，是线程安全的，但是在一些特定的调用顺序中，需要额外的同步保证线程安全，如HashTable类</p><h4 id="线程兼容">线程兼容</h4><p>对象本身不是线程安全的，但是通过同步手段保证对象在并发中安全使用</p><h4 id="线程对立">线程对立</h4><p>无论是否使用了同步手段，都无法保证线程安全的代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java与线程模型</title>
      <link href="/2020/07/19/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/19/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java与线程模型">Java与线程模型</h2><h3 id="线程的实现">线程的实现</h3><h4 id="内核线程实现">内核线程实现</h4><ul><li><p>定义：内核线程（Kernel-Level Thread，KLT）：直接由操作系统内核支持的线程，由内核来完成线程切换</p></li><li><p>优势：实现依赖内核，实现简单</p></li><li><p>劣势：部分操作需要从用户态切换到内核态，开销较大</p></li></ul><h4 id="用户线程实现">用户线程实现</h4><ul><li><p>定义</p><ul><li>广义：一个线程不是内核线程，就可以认为是用户线程，在这个定义上讲，轻量级进程也是用户线程，但是轻量级进程的实现是建立在内核之上的，需要进行系统调用，效率会受到影响</li><li>狭义：用户线程指的是完全建立在用户空间的线程库上的线程实现，内核无法感知到用户线程。用户线程的建立、同步、销毁和调度在用户态完成，无需切换到内核态，操作消耗较低。</li></ul></li><li><p>优势</p><ul><li>操作消耗低</li><li>支持规模更大的线程数量</li></ul></li><li><p>劣势</p><ul><li>实现十分复杂</li></ul></li></ul><h4 id="用户线程-轻量级进程混合实现">用户线程+轻量级进程混合实现</h4><ul><li><p>定义</p><ul><li>轻量级进程（Light Weight Process，LWP）：内核线程的一个高级接口，通常意义上的线程，每个轻量级进程都有一个内核线程支持</li><li>用户线程+轻量级进程混合实现：轻量级进程作为用户线程和内核线程的桥梁，使得用户线程可以使用内核提供的线程调度功能、处理器映射。用户线程和轻量级进程数量比不定，为N：M</li></ul></li></ul><h4 id="Java线程的实现">Java线程的实现</h4><ul><li>jdk1.2之前：用户线程（绿色线程）实现</li><li>jdk1.2：基于操作系统原生线程模型实现，Sun JDK使用java线程和轻量级进程是1:1的模型</li></ul><h3 id="Java线程调度">Java线程调度</h3><h4 id="调度方式">调度方式</h4><ul><li><p>协同式线程调度（Cooperative Threads-Scheduling）</p><ul><li><p>定义：线程执行时间由线程自己决定</p></li><li><p>优点：实现简单</p></li><li><p>缺点：某一线程执行时间过长会导致系统崩溃</p></li></ul></li><li><p>抢占式线程调度（Preemptive Thread-Scheduling）（Java线程调度）</p><ul><li><p>定义：线程由系统分配执行时间</p></li><li><p>优点：每个线程都可以分配到cpu时间分片</p></li><li><p>缺点：需要保存现场，切换上下文时有额外的开销</p></li></ul></li></ul><h4 id="线程优先级">线程优先级</h4><ul><li>Java线程优先级：1-10级</li><li>Windows线程优先级：1-7级</li><li>Solaris线程优先级：2^32级</li></ul><h3 id="状态转换">状态转换</h3><ul><li><p>新建（New）：创建后还没有启动的线程处于这种状态</p></li><li><p>运行（Running）：包括了操作系统线程状态中Running和Ready，就是说在这个状态的线程，可能在执行，也可能等待CPU分配执行时间</p></li><li><p>无限期等待（Waiting）：处于这种状态的线程不会分配到CPU执行时间，需要被其他线程显式唤醒</p><ul><li>没有设置Timeout参数的Object.wait()方法</li><li>没有设置Timeout参数的Thread.join()方法</li><li>LockSupport.park()方法</li></ul></li><li><p>限期等待（Timed Waiting）：处于这个状态的线程不会被分配CPU执行时间，不过无须等待被其他线程显式唤醒，在一定时间后会由系统自动唤醒</p><ul><li>Thread.sleep()方法</li><li>设置了Timeout参数的Object.wait()方法</li><li>设置了Timeout参数的Thread.join()方法</li><li>LockSupport.parkNanos()方法</li><li>LockSupport.parkUntil()方法</li></ul></li><li><p>阻塞（Blocked）：线程被阻塞，线程在等待获取一个排它锁时，进入阻塞状态，在另一个线程放弃这个锁时，返回Running状态</p></li><li><p>结束（Terminated）：线程已经结束执行</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池的四种预设创建方式和原生创建方式</title>
      <link href="/2020/07/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%A2%84%E8%AE%BE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%94%9F%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%A2%84%E8%AE%BE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%94%9F%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java线程池">Java线程池</h2><h3 id="什么是线程池？">什么是线程池？</h3><p>线程池负责维护一个或多个线程的运行，让我们在实际的项目编码中不用自己编写维护线程的逻辑，简化编程，提高代码的鲁棒性，易读性。</p><h3 id="线程池的创建方法">线程池的创建方法</h3><h4 id="通过java-util-concurrent-ThreadPoolExecutor创建">通过java.util.concurrent.ThreadPoolExecutor创建</h4><h5 id="构造方法">构造方法</h5><p>ThreadPoolExecutor构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略实际代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造参数</p><ul><li>corePoolSize：核心线程大小</li><li>maxiumumPoolSize：最大线程大小</li><li>keepAliveTime：非核心线程的闲置线程存活时间</li><li>unit：闲置时间单位</li><li>workQueue：工作队列</li><li>threadFactory：线程工厂</li><li>handler：线程溢出处理</li></ul><h5 id="线程池规则">线程池规则</h5><ol><li>如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。<br>如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是LinkedBlockingDeque的时候，超过核心线程数量的任务会放在任务队列中排队。</li><li>如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。</li><li>如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是LinkedBlockingDeque，会将超过核心线程的任务放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设置是无效的，他的线程数最多不会超过核心线程数。</li><li>如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是SynchronousQueue的时候，会因为线程池拒绝添加任务而抛出异常。</li></ol><h4 id="通过java-util-concurrent-Executors的四种预设创建方式">通过java.util.concurrent.Executors的四种预设创建方式</h4><p>实际上通过Executors的预设创建线程池，也是通过ThreadPoolExecutor类创建</p><ul><li>newCachedThreadPool：创建核心线程数为0，最大线程为Integer.MAX的线程池，进入线程池的线程会立刻执行，闲置超过60s清除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors.newCachedThreadPool()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>newFixedThreadPool ：创建指定核心线程数，最大线程数与核心线程数相同，没有非核心线程所以闲置时间为0，当前核心线程运行中的线程&lt;最大线程时，线程立刻执行，否则压队列，队列中线程会在核心线程中的线程执行完后执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors.newFixedThreadPool()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors.newScheduledThreadPool()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>newSingleThreadExecutor：创建一个同时只有一个线程执行的线程池，超过执行数量的线程会进入队列，和newFixedThreadPool的区别只有同时运行线程数的区别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors.newSingleThreadExecutor()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记(二)：redis的数据结构(三)列表</title>
      <link href="/2020/07/14/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%89-%E5%88%97%E8%A1%A8/"/>
      <url>/2020/07/14/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%89-%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构——列表（List）">数据结构——列表（List）</h2><h3 id="什么是列表？">什么是列表？</h3><p>Redis列表是一串字符串列表，按照插入顺序排序，可以从左边（头部）或者右边（尾部）进行数据的插入，一个列表最大支持2^32-1个元素插入。</p><a id="more"></a><h3 id="常用命令-2">常用命令</h3><h4 id="添加">添加</h4><h5 id="从右边插入元素">从右边插入元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...]</span><br></pre></td></tr></table></figure><h5 id="从左边插入元素">从左边插入元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value ...]</span><br></pre></td></tr></table></figure><h5 id="向某个元素前-后插入元素">向某个元素前/后插入元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linsert key before|after pivot value</span><br></pre></td></tr></table></figure><h4 id="查找">查找</h4><h5 id="获取指定范围内元素列表">获取指定范围内元素列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end</span><br></pre></td></tr></table></figure><h5 id="获取指定索引下标元素">获取指定索引下标元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure><h5 id="获取列长度">获取列长度</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><h5 id="从左边弹出元素">从左边弹出元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br></pre></td></tr></table></figure><h5 id="从右边弹出元素">从右边弹出元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure><h5 id="删除指定元素">删除指定元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><h5 id="按照索引范围修整列表">按照索引范围修整列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure><h4 id="阻塞">阻塞</h4><h5 id="阻塞弹出">阻塞弹出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brpop&#x2F;blpop key [keys] seconds</span><br></pre></td></tr></table></figure><h3 id="内部编码-2">内部编码</h3><ul><li><p>ziplist<br>哈希类型元素小于hash-max-ziplist-entries(默认512个)<br>所有值都小于hash-max-ziplist-value(默认64字节)</p></li><li><p>linkedlist<br>不满足ziplist条件时，转换为linkedlist</p></li><li><p>quicklist(v3.2版本添加)</p></li></ul><h3 id="使用场景-2">使用场景</h3><ul><li>消息队列（lpush+brpop）</li><li>栈（lpush+lpop）</li><li>队列（lpush+rpop）</li><li>有限集合（lpush+ltrim）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot Jvm虚拟机常用调优参数</title>
      <link href="/2020/07/09/HotSpot-Jvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/"/>
      <url>/2020/07/09/HotSpot-Jvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Jvm调优的目的">Jvm调优的目的</h2><ul><li>为使得jvm虚拟机在不同硬件配置的机器上获取更好的性能，以及更好的稳定性，调整默认的jvm可以使得我们的程序在性能上有所提升。如：</li></ul><ol><li>如项目中有大量的新对象的寿命很短，可以适当把新生代的大小调整到合适的大小。</li><li>调整新生代进入老年代的阈值，使得避免新生代多次复制GC一些大概率会进入老年代的对象。</li></ol><p><strong>注意</strong>：JVM调优需要针对当前项目的特点进行调整，最好在调优前使用分析插件分析程序在运行时的内存使用情况，再针对性进行优化。</p><h3 id="JVM常用的优化参数">JVM常用的优化参数</h3><h5 id="堆最大大小">堆最大大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m</span><br></pre></td></tr></table></figure><h5 id="堆初始大小">堆初始大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m</span><br></pre></td></tr></table></figure><h5 id="新生代大小">新生代大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure><h5 id="单个栈最大大小">单个栈最大大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 1m</span><br></pre></td></tr></table></figure><h5 id="新生代分区比例-8-2">新生代分区比例 8:2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio&#x3D;8</span><br></pre></td></tr></table></figure><h5 id="调整对象直接在老年代分配的阈值，单位K">调整对象直接在老年代分配的阈值，单位K</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold&#x3D;3145728</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> hotspot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos的mysql安装</title>
      <link href="/2020/03/02/Centos%E7%9A%84mysql%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/02/Centos%E7%9A%84mysql%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h4 id="Centos-的mysql安装">Centos 的mysql安装</h4><h5 id="下载">下载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure><h5 id="安装-mysql-源">安装 mysql 源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">yum repolist enabled | grep "mysql.*-community.*"  //检查 mysql 源是否安装成功</span><br></pre></td></tr></table></figure><h5 id="安装-MySQL">安装 MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure><h5 id="启动Mysql服务">启动Mysql服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl enable mysqld //开机启动</span><br></pre></td></tr></table></figure><h5 id="获取初始密码，登录">获取初始密码，登录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep root</span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h5 id="修改root密码">修改root密码</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>; //设置密码策略为简单</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'Ching1569'</span></span><br></pre></td></tr></table></figure><h5 id="授权远程访问">授权远程访问</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><h5 id="小内存机器mysql内存调优">小内存机器mysql内存调优</h5><p><a href="%22http://ziry.me/view/91%22">mysql内存调优</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法糖</title>
      <link href="/2020/02/08/Java%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2020/02/08/Java%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-语法糖">Java 语法糖</h3><h4 id="1-switch支持String和枚举">1. switch支持String和枚举</h4><p>在jdk1.7后，switch支持String和枚举，在这之前switch只支持int、char、short、byte以及其包装类Integer、Character、Short、Byte；char则转换为ascII码值就行匹配，实际还是转换为java基本类型。</p><p>switch在处理String和枚举类时，实际上调用了hashcode()和equal()方法进行匹配，hashcode()方法将类型转换为int，而由于哈希存在碰撞的可能性，还需要进行一次equal()进行安全校验。</p><h4 id="2-泛型">2. 泛型</h4><p>多种编程语言都支持泛型，泛型的实现有两种：<strong>Code specialization</strong> 和 <strong>Code sharing</strong></p><blockquote><p>Code sharing的含义是共享字节码/目标代码，通过类型擦除，擦除后使用的是同一份字节码/目标代码。</p></blockquote><p>Java在类型擦除时按照两个规则：</p><ol><li>将所有的泛型类型用其最左边界（最顶级父类型）类型替换。</li><li>移除所有类型参数</li></ol><h4 id="3-自动装箱与拆箱">3. 自动装箱与拆箱</h4><p>自动装箱是Java将int、byte、short、long、char、double、float、boolean基础类型，自动转换为Integer、Byte、Short、Long、Character、Double、Float、Boolean包装类。<br>自动拆箱则反之。</p><p>自动装箱例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long l = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long l = Long.valueOf(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long l = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">long</span> l1 = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long l = Long.valueOf(<span class="number">1L</span>);</span><br><span class="line">    <span class="keyword">long</span> l1 = l.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反编译后的代码看出，实际上自动装箱是使用valueOf()方法实现，自动拆箱使用xxxValue()方法实现。</p><h4 id="4-方法变长参数">4. 方法变长参数</h4><p>可变长参数的实现：用数组实现，将多个参数封装成数组</p><h4 id="5-枚举">5. 枚举</h4><p>枚举类是Java语法糖之一，java枚举类隐式继承java.lang.Enum，所以枚举类不能继承其他类（Java单继承），但可以实现接口。<br>枚举类会继承values()、valuesOf()方法，枚举类中的枚举实例实际上是其本身的类实例并声明了public static final，所以对于枚举实例，可以声明变量外，还可以重写方法。<br>在Color中，GREEN实例重写了sayName方法，调用重写了方法的实例和无重写，会有不同的效果。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    GREEN(<span class="number">301</span>, <span class="string">"绿色"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"绿色!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    YELLOW(<span class="number">302</span>, <span class="string">"黄色"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"黄色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    RED(<span class="number">303</span>, <span class="string">"红色"</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Color(Integer code, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Colorful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Color.RED.sayName():"</span>);</span><br><span class="line">        Color.RED.sayName();</span><br><span class="line">        System.out.print(<span class="string">"Color.GREEN.sayName():"</span>);</span><br><span class="line">        Color.GREEN.sayName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line">Color.RED.sayName():Colorful</span><br><span class="line">Color.GREEN.sayName():绿色!!!</span><br></pre></td></tr></table></figure><h4 id="6-内部类">6. 内部类</h4><h4 id="7-条件编译">7. 条件编译</h4><h4 id="8-断言">8. 断言</h4><h4 id="9-数值字面量">9. 数值字面量</h4><h4 id="10-for-each">10. for-each</h4><h4 id="11-try-with-resource">11. try-with-resource</h4><h4 id="12-Lambda表达式">12. Lambda表达式</h4><p><a href="https://juejin.im/post/5cd8c5e6f265da03555c9d79?utm_source=gold_browser_extension%22%3Ehttps://juejin.im/post/5cd8c5e6f265da03555c9d79?utm_source=gold_browser_extension" target="_blank" rel="noopener">Hollis原创|不了解这12个语法糖，别说你会Java</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记(二)：redis的数据结构(二)哈希</title>
      <link href="/2020/02/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C-%E5%93%88%E5%B8%8C/"/>
      <url>/2020/02/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C-%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="前言-3">前言</h3><p>在前篇中，我们已经了解了redis的字符串了，接下来让我们继续学习Redis的数据结构——哈希（Hash）类型。</p><a id="more"></a><h3 id="数据结构——哈希（hash）">数据结构——哈希（hash）</h3><h4 id="什么是哈希（hash）？">什么是哈希（hash）？</h4><p>如果你是Java、Python的工程师，相信你对键值（key-value）对很熟悉，在redis中hash就是一个键值对结构的数据类型，即field-value，一个hash由一个或多个field-value键值对组成。</p><img src="/.io//02/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C-%E5%93%88%E5%B8%8C/hash1.png" class title="hash_teach"><h4 id="常用命令-3">常用命令</h4><h5 id="1-设置值">1. 设置值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><h5 id="2-获取值">2. 获取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br></pre></td></tr></table></figure><h5 id="3-删除field">3. 删除field</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field...]</span><br></pre></td></tr></table></figure><h5 id="4-计算field个数">4. 计算field个数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><h5 id="5-批量获取field-value">5. 批量获取field-value</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]</span><br></pre></td></tr></table></figure><h5 id="6-批量设置field-value">6. 批量设置field-value</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field value[field value...]</span><br></pre></td></tr></table></figure><h5 id="7-判断field是否存在">7. 判断field是否存在</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h5 id="8-获取所有field">8. 获取所有field</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure><h5 id="9-获取所有value">9. 获取所有value</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure><h5 id="10-获取所有field-value">10. 获取所有field-value</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure><h5 id="11-自增-field">11. 自增 field</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br></pre></td></tr></table></figure><h5 id="12-自增-field-float">12. 自增 field (float)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrbyfloat key field</span><br></pre></td></tr></table></figure><h5 id="13-计算value字符串长度">13. 计算value字符串长度</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br></pre></td></tr></table></figure><h4 id="内部编码-3">内部编码</h4><ol><li>ziplist（压缩列表）：当哈希类型中field个数小于<strong>hash-max-ziplist-entries</strong>（默认512个）配置时并且所有值小于<strong>hash-max-ziplist-value</strong>（默认64Bytes）使用ziplist编码，多个元素连续存储，所有ziplist编码更加紧凑，对比hashtable更加节省内存，但读写效率相对降低。</li><li>hashtable（哈希表）：当哈希类型不符合ziplist的存储要求时，则会转换编码类型为hashtable，hashtable的读写性能更好，读写时间复杂度为O(1)。</li></ol><h4 id="使用场景-3">使用场景</h4><ol><li>缓存读多写少的数据查询记录</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记(二)：redis的数据结构(一)字符串</title>
      <link href="/2020/01/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/01/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%EF%BC%9Aredis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>上一节中详细解析的什么是Redis，以及Redis能够解决什么问题，不能解决什么问题。非常好，我们终于可真正开始学习Redis了！<br>本篇将会解析Redis数据结构中字符串的<strong>命令</strong>、<strong>适用场景</strong>，以及<strong>内部编码</strong></p><a id="more"></a><h3 id="redis的数据结构">redis的数据结构</h3><h4 id="string-字符串">string(字符串)</h4><h4 id="redis的字符串是什么？">redis的字符串是什么？</h4><p>以单个字符串存储的数据结构，是redis其他数据结构的基础。在redis中，字符串会有多种存储形式，如数字类型为整数，并小于<strong>2^63 -1</strong>时，会以int型存储，占8Byte；大于<strong>2^63-1</strong>时会转为另一种编码存储，在稍后的内部编码会做解释。</p><h4 id="常用命令">常用命令</h4><h5 id="设置值">设置值</h5><ul><li>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><table><thead><tr><th>参数</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>ex</td><td>设置过期时间，单位second</td><td>set site <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a> ex 10</td></tr><tr><td>nx</td><td>仅当键不存在时，设置成功</td><td>set site <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a> nx</td></tr><tr><td>xx</td><td>仅当键存在时，设置成功（更新）</td><td>set site <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a> xx</td></tr></tbody></table><h5 id="获取值">获取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><h5 id="批量设置值">批量设置值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value...]</span><br></pre></td></tr></table></figure><h5 id="批量获取值">批量获取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key...]</span><br></pre></td></tr></table></figure><h5 id="计数">计数</h5><table><thead><tr><th>命令</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>incr key</td><td>int型自增1</td><td>incr score</td></tr><tr><td>decr key</td><td>int型自减1</td><td>decr score</td></tr><tr><td>incrby key increment</td><td>int型自增</td><td>incrby score 10</td></tr><tr><td>decrby key decrement</td><td>int型自减</td><td>decrby score 10</td></tr><tr><td>incrbyfloat key increment</td><td>浮点型自增</td><td>incrbyfloat float1 1.12</td></tr></tbody></table><h4 id="不常用命令">不常用命令</h4><table><thead><tr><th>命令</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>strlen key</td><td>字符串长度</td><td>strlen str1</td></tr><tr><td>append key value</td><td>追加值</td><td>append site <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a></td></tr><tr><td>getset key value</td><td>设置并返回原值</td><td>getset site <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a></td></tr><tr><td>setrange key offeset value</td><td>设置指定位置的字符</td><td>setrange site 2 <a href="http://chingk.com" target="_blank" rel="noopener">chingk.com</a></td></tr></tbody></table><h4 id="内部编码">内部编码</h4><table><thead><tr><th>编码</th><th>内容</th><th>大小</th></tr></thead><tbody><tr><td>int</td><td>整数型，大于-2^63,小于2^63-1</td><td>8Byte</td></tr><tr><td>embstr</td><td>字符型，小于等于39字节的字符串</td><td>&gt;=1Byte,&lt;=39Byte</td></tr><tr><td>raw</td><td>字符型，大于39字节的字符串</td><td>&gt;39Byte</td></tr></tbody></table><h4 id="使用场景">使用场景</h4><p>redis由于使用单线程模型，不会出现aba问题，所以字符串适合<strong>计数</strong>，此外redis字符串类型常用的场景是<strong>缓存</strong>，一般缓存的格式<strong>业务名：对象名：id：[属性]</strong> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记(一)：初识redis</title>
      <link href="/2020/01/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%88%9D%E8%AF%86redis/"/>
      <url>/2020/01/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%88%9D%E8%AF%86redis/</url>
      
        <content type="html"><![CDATA[<h3 id="前言-2">前言</h3><p>本节将在Redis这一中间件技术的由来、版本迭代、Redis的基础特性等方面介绍，帮助读者了解Redis，为学习Redis打下基础。</p><a id="more"></a><h3 id="Redis的基础">Redis的基础</h3><h4 id="Redis是什么？">Redis是什么？</h4><p>redis（<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于<strong>键值对</strong>的数据结构服务器，数据主要存储于内存，被称为NoSql（Not Only sql），可以实现快速的数据读写、数据持久化、分布式部署等功能，实现高可用。</p><h4 id="Redis的特性">Redis的特性</h4><h5 id="速度快">速度快</h5><ol><li>由于Redis<strong>使用内存存储</strong>，redis可以直接从内存检索数据，对比从磁盘获取读入内存提升大约两个数量级，读写性能可以达到10万/s，具体性能取决于实际机器的配置。</li><li>在内存存储的基础上，Redis<strong>采用了单线程</strong>架构，因为多线程环境中，可能产生竞争，锁的开销极大，单线程可以简化编程，防止aba问题的出现，由于基于内存存储，单线程也能做到极大的吞吐量。</li><li>Redis采用了c语言编写，执行效率更高</li><li>代码优化，Redis的代码优化程度很高，集性能与优雅于一身。</li></ol><ul><li><strong>表1-1 谷歌公司给出的各层级硬件执行速度</strong></li></ul><table><thead><tr><th>层级</th><th>速度</th></tr></thead><tbody><tr><td>L1 cache reference</td><td>0.5ns</td></tr><tr><td>Branch mispredict</td><td>5ns</td></tr><tr><td>L2 cache reference</td><td>7ns</td></tr><tr><td>Mute lock/unlock</td><td>25ns</td></tr><tr><td>Main memory reference</td><td>100ns</td></tr><tr><td>Compress 1K bytes with Zippy</td><td>3,000ns</td></tr><tr><td>Send 2K bytes over 1Gbps network</td><td>20,000ns</td></tr><tr><td>Read 1MB sequentially from Memory</td><td>250,000ns</td></tr><tr><td>Round trip within same datacenter</td><td>500,000ns</td></tr><tr><td>Disk seek</td><td>10,000,000ns</td></tr><tr><td>Read 1MB sequentially from disk</td><td>20,000,000ns</td></tr><tr><td>Send packet CA-&gt;Netherlands-&gt;CA</td><td>150,000,000ns</td></tr></tbody></table><h5 id="基于键值对的数据结构">基于键值对的数据结构</h5><p>redis全称<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver，远程数据字典服务器，描述了Redis的数据组织方式，Redis的数据结构类似字典功能，如Java中的Map、Python里的dict。它主要提供了5种数据结构：字符串、哈希、 列表、 集合、有序集合。同时在字符串的基础上，演变出来了Bitmaps和HyperLogLog两种“数据结构”。</p><h5 id="丰富的功能">丰富的功能</h5><ol><li>键过期</li><li>发布订阅</li><li>Lua脚本</li><li>简单事务</li><li>流水线（PineLine）批量执行redis命令</li></ol><h5 id="简单稳定">简单稳定</h5><ol><li>代码少，3.0版本前2万行左右，3.0后添加了集群5万行左右，开发运维人员可以很快吃透，并自定义优化。</li><li>不依赖操作系统类库，redis自己实现了事务处理的相关功能。</li></ol><h5 id="客户端语言支持广泛">客户端语言支持广泛</h5><ol><li>Java</li><li>Php</li><li>Python</li><li>C</li><li>C++</li><li>Node.js</li></ol><h5 id="持久化">持久化</h5><p>redis为了防止redis服务宕机，导致数据丢失，提供了AOF和RDB两种持久化策略，在之后的章节中会讲解。</p><h5 id="主从复制">主从复制</h5><p>redis提供了复制功能，实现多个相同的redis副本。</p><h5 id="高可用和分布式">高可用和分布式</h5><p>redis官方实现了Redis Cluster，国内多使用Codis作为redis的分布式集群。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos的docker安装</title>
      <link href="/2019/11/20/Centos%E7%9A%84docker%E5%AE%89%E8%A3%85/"/>
      <url>/2019/11/20/Centos%E7%9A%84docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="Centos的docker安装">Centos的docker安装</h3><h4 id="卸载旧版本">卸载旧版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker  docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="安装-Docker-Engine-Community">安装 Docker Engine-Community</h4><ul><li>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure><ul><li>yum-config-manager添加aliyun镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><h4 id="安装Docker">安装Docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h4 id="启动docker并设置开机启动">启动docker并设置开机启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个代码自动生成（二）：FTL语法篇</title>
      <link href="/2019/06/28/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AFTL%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
      <url>/2019/06/28/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AFTL%E8%AF%AD%E6%B3%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-4">前言</h2><p>前一篇博客介绍了FreeMarker如何在Maven项目中的使用，以及最基本的数据模型和模板的创建，最后执行了一次代码生成，在这里恭喜您你已经踏出了第一步了，相信您在了解了本篇的ftl语法后，对FreeMarker会进一步熟悉这个</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> freeMarker </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个代码自动生成（一）：模板引擎Freemarker使用</title>
      <link href="/2019/06/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreemarker%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreemarker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-5">前言</h2><p>在现在的开发当中，代码生成已经是必不可少的一个功能，每个公司都会有自己的一套定制的项目骨架，而实现代码自动生成，模板引擎是必不可少的，所以在这篇博客中，将会讲解freemarker在代码生成中所扮演的角色，以及介绍如何在Java项目中使用它！</p><a id="more"></a><h2 id="模板引擎FreeMarker">模板引擎FreeMarker</h2><h4 id="模板引擎是什么？">模板引擎是什么？</h4><p>模板引擎一般指将通用代码和业务数据分离开来的技术，该技术有多种实现，如置换型、解释型、编译型，如JSP就是其中一种应用非常广泛的模板引擎技术（其本质是一个Servlet，用来生成Html文件）</p><h4 id="FreeMarker是什么？">FreeMarker是什么？</h4><p>官方文档：</p><blockquote><p>FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。<br>模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p></blockquote><p><strong>简单来讲就是FreeMarker把目标文本分解成了Model、View，然后引擎自身充当了Controller，也就是常见的MVC模式。<br>FreeMarker通过预先定义好的模板文件（ftl文件），再把如Java对象中的属性进行填充，最后输出目标文件。</strong></p><img src="/.io//06/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreemarker%E4%BD%BF%E7%94%A8/auto-1.png" class title="img1"><h4 id="FreeMarker如何使用？">FreeMarker如何使用？</h4><p>FreeMarker不像JSP，需要绑定Servlet才能使用，在Java中我们只需要导入对应的Jar包就可以使用了！接下来会介绍在<strong>Maven项目</strong>中如何使用FreeMarker。</p><h5 id="加入依赖">加入依赖</h5><p>首先我们先在<strong>pom.xml</strong>中加入FreeMarker的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建Configuration实例">创建Configuration实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step1 创建freemarker.template.Configuration配置实例</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(Configuration.VERSION_2_3_22);</span><br></pre></td></tr></table></figure><h5 id="创建数据模型">创建数据模型</h5><p>我们可以使用一个String，或者以下的类型的实例充当数据模型，在这里使用了一个<strong>自定义的Bean</strong>。</p><blockquote><p>使用 java.lang.String 来构建字符串。<br>使用 java.lang.Number 来派生数字类型。<br>使用 java.lang.Boolean 来构建布尔值。<br>使用 java.util.List 或Java数组来构建序列。<br>使用 java.util.Map 来构建哈希表。<br>使用自定义的bean类来构建哈希表，bean中的项和bean的属性对应。比如， product 的 price 属性 (getProperty())可以通过 product.price 获取。(bean的action也可以通过这种方式拿到； 要了解更多可以参看 这里)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个root hash对象，用来装载数据对象</span></span><br><span class="line">Map&lt;String, Object&gt; root = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//将数据对象装载入hash中</span></span><br><span class="line">root.put(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"Joe"</span>,<span class="number">17</span>));</span><br></pre></td></tr></table></figure><p>使用到的自定义的User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    User(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>创建一个模板文件(.ftl文件)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--!</span> <span class="attr">demo.ftl</span> <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>user.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>user.age<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="获取模板">获取模板</h5><p>获取之前我们创建的demo.ftl模板文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Template temp = cfg.getTemplate(<span class="string">"demo.ftl"</span>);</span><br></pre></td></tr></table></figure><h5 id="合并模板和数据">合并模板和数据</h5><p>我们在了解FreeMarker的开始就知道，数据模型+模板=目标输出，在最后，我们只需要将获取到的模板，和自定义的root hash对象进行绑定，这里会使用到Template的process()方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建输出流，定义输出的文件</span></span><br><span class="line">File docFile = <span class="keyword">new</span> File(<span class="string">"demo.xml"</span>);</span><br><span class="line">out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(docFile)));</span><br><span class="line"><span class="comment">//process方法将数据与模板进行绑定，输出到out输出流</span></span><br><span class="line">temp.process(root, out);</span><br></pre></td></tr></table></figure><h5 id="整合代码">整合代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建freemarker.template.Configuration配置实例</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(Configuration.VERSION_2_3_22);</span><br><span class="line"><span class="comment">//创建一个root hash对象，用来装载数据对象</span></span><br><span class="line">Map&lt;String, Object&gt; root = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//将数据对象装载入hash中</span></span><br><span class="line">root.put(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"Joe"</span>,<span class="number">17</span>));</span><br><span class="line"><span class="comment">//获取模板</span></span><br><span class="line">Template temp = cfg.getTemplate(<span class="string">"demo.ftl"</span>);</span><br><span class="line"><span class="comment">//创建输出流，定义输出的文件</span></span><br><span class="line">File docFile = <span class="keyword">new</span> File(<span class="string">"demo.xml"</span>);</span><br><span class="line">out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(docFile)));</span><br><span class="line"><span class="comment">//process方法将数据与模板进行绑定，输出到out输出流</span></span><br><span class="line">temp.process(root, out);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> freeMarker </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
